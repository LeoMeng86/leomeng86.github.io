{"title":"数据结构第三次上机实验","uid":"9273a260bb46152a3f86150e633d4306","slug":"数据结构第三次上机实验","date":"2022-09-06T03:59:53.000Z","updated":"2023-02-28T17:40:58.041Z","comments":true,"path":"api/articles/数据结构第三次上机实验.json","keywords":null,"cover":null,"content":"<h2 id=\"第一题：连通分量\"><a href=\"#第一题：连通分量\" class=\"headerlink\" title=\"第一题：连通分量\"></a><strong>第一题：连通分量</strong></h2><p>无向图 G 有 n 个顶点和 m 条边。求 G 的连通分量的数目。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a><strong>输入格式：</strong></h3><p>第1行，2个整数n和m，用空格分隔，分别表示顶点数和边数， 1≤n≤50000， 1≤m≤100000.</p>\n<p>第2到m+1行，每行两个整数u和v，用空格分隔，表示顶点u到顶点v有一条边，u和v是顶点编号，1≤u,v≤n.</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a><strong>输出格式：</strong></h3><p>1行，1个整数，表示所求连通分量的数目。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a><strong>输入样例：</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">6 5\n1 3\n1 2\n2 3\n4 5\n5 6</code></pre>\n\n<h3 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a><strong>输入样例：</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">2</code></pre>\n\n<h3 id=\"题目解析：\"><a href=\"#题目解析：\" class=\"headerlink\" title=\"题目解析：\"></a><strong>题目解析：</strong></h3><h4 id=\"方法一：深度优先遍历\"><a href=\"#方法一：深度优先遍历\" class=\"headerlink\" title=\"方法一：深度优先遍历\"></a><strong>方法一：深度优先遍历</strong></h4><p>通过对每一个连通分量进行DFS（深度优先遍历），来遍历这个连通分量的所有节点，使用vis数组判断是否位于该节点是否位于原来已经遍历过的连通分量中，使用cnt变量来记录分支数量。</p>\n<h5 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h5><h6 id=\"读入无向图（邻接表）\"><a href=\"#读入无向图（邻接表）\" class=\"headerlink\" title=\"读入无向图（邻接表）\"></a>读入无向图（邻接表）</h6><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void add(int &amp; a, int &amp; b)\n&#123;\n    node* tmp &#x3D; phead[a];\n    if(tmp &#x3D;&#x3D; nullptr)\n    &#123;\n        tmp &#x3D; new node;\n        tmp-&gt;val &#x3D; b;\n        phead[a] &#x3D; tmp;\n        ptail[a] &#x3D; tmp;\n    &#125;\n    else&#123;\n        tmp &#x3D; new node;\n        tmp-&gt;val &#x3D; b;\n        ptail[a]-&gt;next &#x3D; tmp;\n        ptail[a] &#x3D; tmp;\n    &#125;\n\n    tmp &#x3D; phead[b];\n    if(tmp &#x3D;&#x3D; nullptr)\n    &#123;\n        tmp &#x3D; new node;\n        tmp-&gt;val &#x3D; a;\n        phead[b] &#x3D; tmp;\n        ptail[b] &#x3D; tmp;\n    &#125;\n    else&#123;\n        tmp &#x3D; new node;\n        tmp-&gt;val &#x3D; a;\n        ptail[b]-&gt;next &#x3D; tmp;\n        ptail[b] &#x3D; tmp;\n    &#125;\n&#125;</code></pre>\n\n<h6 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h6><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void DFS(int x)\n&#123;\n    vis[x] &#x3D; 1;\n    node* t &#x3D; phead[x];\n    while(t !&#x3D; nullptr)\n    &#123;\n        if(vis[t-&gt;val] &#x3D;&#x3D; 0) DFS(t-&gt;val);\n        t &#x3D; t-&gt;next;\n    &#125;\n&#125;</code></pre>\n\n<h6 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h6><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nclass node\n&#123;\npublic:\n    int val;\n    node* next;\n    node()&#123;next &#x3D; nullptr;&#125;\n&#125;;\n\nnode* phead[50001] &#x3D; &#123;nullptr&#125;;\nnode* ptail[50001] &#x3D; &#123;nullptr&#125;;\nint vis[50001] &#x3D; &#123;0&#125;;\n\nint n, m, v1, v2, cnt &#x3D; 0;\n\nvoid add(int &amp; a, int &amp; b)\n&#123;\n    node* tmp &#x3D; phead[a];\n    if(tmp &#x3D;&#x3D; nullptr)\n    &#123;\n        tmp &#x3D; new node;\n        tmp-&gt;val &#x3D; b;\n        phead[a] &#x3D; tmp;\n        ptail[a] &#x3D; tmp;\n    &#125;\n    else&#123;\n        tmp &#x3D; new node;\n        tmp-&gt;val &#x3D; b;\n        ptail[a]-&gt;next &#x3D; tmp;\n        ptail[a] &#x3D; tmp;\n    &#125;\n\n    tmp &#x3D; phead[b];\n    if(tmp &#x3D;&#x3D; nullptr)\n    &#123;\n        tmp &#x3D; new node;\n        tmp-&gt;val &#x3D; a;\n        phead[b] &#x3D; tmp;\n        ptail[b] &#x3D; tmp;\n    &#125;\n    else&#123;\n        tmp &#x3D; new node;\n        tmp-&gt;val &#x3D; a;\n        ptail[b]-&gt;next &#x3D; tmp;\n        ptail[b] &#x3D; tmp;\n    &#125;\n&#125;\n\nvoid DFS(int x)\n&#123;\n    vis[x] &#x3D; 1;\n    node* t &#x3D; phead[x];\n    while(t !&#x3D; nullptr)\n    &#123;\n        if(vis[t-&gt;val] &#x3D;&#x3D; 0) DFS(t-&gt;val);\n        t &#x3D; t-&gt;next;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i &#x3D; 0; i &lt;&#x3D; m - 1; i++)\n    &#123;\n        cin &gt;&gt; v1 &gt;&gt; v2;\n        add(v1, v2);\n    &#125;\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        if(vis[i] &#x3D;&#x3D; 0)\n        &#123;\n            DFS(i);\n            cnt++;\n        &#125;\n    &#125;\n    cout &lt;&lt; cnt &lt;&lt; endl;\n    return 0;\n&#125;</code></pre>\n\n<h5 id=\"方法二：并查集\"><a href=\"#方法二：并查集\" class=\"headerlink\" title=\"方法二：并查集\"></a><strong>方法二：并查集</strong></h5><p>使用Kruskal算法，用并查集存储每个节点的祖先，最后统计出不同祖先的个数。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nint cost_sum &#x3D; 0;\n\nint pre[50001];\n\nint find(int x)\n&#123;\n    if(pre[x] &#x3D;&#x3D; x) return x;\n    return pre[x] &#x3D; find(pre[x]);\n&#125;\n\nvoid join(int x, int y)\n&#123;\n    int fx &#x3D; find(x), fy &#x3D; find(y);\n    if(fx !&#x3D; fy)\n        pre[fx] &#x3D; fy;\n&#125;\n\nstruct edge\n&#123;\n    int fr, to;\n&#125;;\n\nqueue&lt;edge&gt; list;\n\nint main()\n&#123;\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for(int i &#x3D; 0; i &lt;&#x3D; n; i++)\n    &#123;\n        pre[i] &#x3D; i;\n    &#125;\n\n    for(int i &#x3D; 0 ; i&lt;&#x3D; m - 1 ; i++)\n    &#123;\n        int tmp_fr, tmp_to;\n        cin &gt;&gt; tmp_fr &gt;&gt; tmp_to;\n        edge *Edge &#x3D; new edge;\n        Edge-&gt;fr &#x3D; tmp_fr;\n        Edge-&gt;to &#x3D; tmp_to;\n        list.push(*Edge);\n    &#125;\n\n    while(!list.empty())\n    &#123;\n        edge Edge &#x3D; list.front();\n        list.pop();\n        int vex1 &#x3D; Edge.fr;\n        int vex2 &#x3D; Edge.to;\n        if(find(vex1) !&#x3D; find(vex2))\n        &#123;\n            join(vex1, vex2);\n        &#125;\n    &#125;\n\n    int cnt &#x3D; 0;\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        if(find(i) &#x3D;&#x3D; i) cnt++;\n    &#125;\n    cout &lt;&lt; cnt &lt;&lt;endl;\n    return 0;\n&#125;\n</code></pre>\n\n<h2 id=\"第二题：整数拆分\"><a href=\"#第二题：整数拆分\" class=\"headerlink\" title=\"第二题：整数拆分\"></a><strong>第二题：整数拆分</strong></h2><p>整数拆分是一个古老又有趣的问题。请给出将正整数 n 拆分成 k 个正整数的所有不重复方案。例如，将 5 拆分成 2 个正整数的不重复方案，有如下2组：(1，4)和(2，3)。注意(1，4) 和(4，1)被视为同一方案。每种方案按递增序输出，所有方案按方案递增序输出。</p>\n<h3 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>1行，2个整数n和k，用空格分隔， 1≤k≤n≤50.</p>\n<h3 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>若干行，每行一个拆分方案，方案中的数用空格分隔。最后一行，给出不同拆分方案的总数。</p>\n<h3 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">5 2</code></pre>\n\n<h3 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">1 4\n2 3\n2</code></pre>\n\n<h3 id=\"题目解析\"><a href=\"#题目解析\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><h4 id=\"方法一：回溯法\"><a href=\"#方法一：回溯法\" class=\"headerlink\" title=\"方法一：回溯法\"></a><strong>方法一：回溯法</strong></h4><h5 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h5><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint n &#x3D; 0;\nint k &#x3D; 0;\nint cnt &#x3D; 0;\n\nvector&lt;int&gt; vec;\n\nint solve(int x, int y, int q, int sum)\n&#123;\n    &#x2F;&#x2F;如果数字个数达到k个\n    if (y &#x3D;&#x3D; 0)\n    &#123;\n        &#x2F;&#x2F;如果sum恰好等于n，输出答案\n        if (sum &#x3D;&#x3D; n)\n        &#123;\n            ++cnt;\n            for (auto it &#x3D; vec.begin(); it !&#x3D; vec.end(); ++it)\n            &#123;\n                cout &lt;&lt; *it;\n                if (it !&#x3D; vec.end())\n                    cout &lt;&lt; &quot; &quot;;\n            &#125;\n            cout &lt;&lt; endl;\n            return 0;\n        &#125;\n        else\n        &#123;\n            return 0;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;重复方案的筛选，将大于等于q，小于等于x&#x2F;y的每个数递归solve，保证每个组合元素递增\n    for (int i &#x3D; q; i &lt;&#x3D; x &#x2F; y; ++i)\n    &#123;\n        vec.push_back(i);\n        solve(x - i, y - 1, i, sum + i);\n        vec.pop_back();\n    &#125;\n    return 0;\n&#125;\n\nint main()\n&#123;\n    cin &gt;&gt; n &gt;&gt; k;\n    solve(n, k, 1, 0);\n    cout &lt;&lt; cnt;\n    return 0;\n&#125;</code></pre>\n\n<h2 id=\"第三题：旅行\"><a href=\"#第三题：旅行\" class=\"headerlink\" title=\"第三题：旅行\"></a><strong>第三题：旅行</strong></h2><p>五一要到了,来一场说走就走的旅行吧。当然，要关注旅行费用。由于从事计算机专业，你很容易就收集到一些城市之间的交通方式及相关费用。将所有城市编号为1到n，你出发的城市编号是s。你想知道，到其它城市的最小费用分别是多少。如果可能，你想途中多旅行一些城市，在最小费用情况下，到各个城市的途中最多能经过多少城市。</p>\n<h3 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>第1行，3个整数n、m、s，用空格分隔，分别表示城市数、交通方式总数、出发城市编号， 1≤s≤n≤10000, 1≤m≤100000 。</p>\n<p>第2到m+1行，每行三个整数u、v和w，用空格分隔，表示城市u和城市v的一种双向交通方式费用为w ， 1≤w≤10000。</p>\n<h3 id=\"输出格式-1\"><a href=\"#输出格式-1\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>第1行，若干个整数Pi，用空格分隔，Pi表示s能到达的城市i的最小费用，1≤i≤n，按城市号递增顺序。</p>\n<p>第2行，若干个整数Ci，Ci表示在最小费用情况下，s到城市i的最多经过的城市数，1≤i≤n，按城市号递增顺序。</p>\n<h3 id=\"输入样例-1\"><a href=\"#输入样例-1\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">5 5 1\n1 2 2\n1 4 5\n2 3 4\n3 5 7\n4 5 8</code></pre>\n\n<h3 id=\"输出样例-1\"><a href=\"#输出样例-1\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">0 2 6 5 13\n0 1 2 1 3</code></pre>\n\n<h3 id=\"题目解析-1\"><a href=\"#题目解析-1\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><p>单元最短路问题，首先想到的是Dijkstra。</p>\n<p>求最多经过的城市数，需要对“三角形”进行特判若“两边之和等于第三边”，选择多经过一个城市的路径。</p>\n<h4 id=\"方法一：Dijkstra\"><a href=\"#方法一：Dijkstra\" class=\"headerlink\" title=\"方法一：Dijkstra\"></a><strong>方法一：Dijkstra</strong></h4><h5 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h5><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;limit&gt;\nusing namespace std;\n\nclass node\n&#123;\npublic:\n    int val;\n    int cost;\n    node *next;\n    node() &#123; next &#x3D; nullptr; &#125;\n    node(int v, int c) &#123; val &#x3D; v, cost &#x3D; c, next &#x3D; nullptr; &#125;\n&#125;;\n\nclass edge\n&#123;\npublic:\n    int val;\n    int cost;\n    edge(int c, int v) &#123; val &#x3D; v, cost &#x3D; c; &#125;\n    bool operator&lt;(const edge &amp;b) const\n    &#123;\n        return cost &gt; b.cost;\n    &#125;\n&#125;;\n\nnode *phead[10001] &#x3D; &#123;nullptr&#125;;\nnode *ptail[10001] &#x3D; &#123;nullptr&#125;;\nint vis[10001] &#x3D; &#123;0&#125;;\nint citycnt[10001] &#x3D; &#123;0&#125;;\n\nint n, m, strt, v1, v2, cs;\n\npriority_queue&lt;edge&gt; list;&#x2F;&#x2F;通过优先队列进行优化\n\nint main()\n&#123;\n    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;strt);\n    int *dist &#x3D; new int[n + 1];\n    for (int i &#x3D; 0; i &lt;&#x3D; m - 1; i++)\n    &#123;\n        scanf(&quot;%d%d%d&quot;, &amp;v1, &amp;v2, &amp;cs);\n        node *t &#x3D; ptail[v1];\n        if (t &#x3D;&#x3D; nullptr)\n        &#123;\n            phead[v1] &#x3D; new node(v2, cs);\n            ptail[v1] &#x3D; phead[v1];\n        &#125;\n        else\n        &#123;\n            ptail[v1]-&gt;next &#x3D; new node(v2, cs);\n            ptail[v1] &#x3D; ptail[v1]-&gt;next;\n        &#125;\n\n        t &#x3D; ptail[v2];\n        if (t &#x3D;&#x3D; nullptr)\n        &#123;\n            phead[v2] &#x3D; new node(v1, cs);\n            ptail[v2] &#x3D; phead[v2];\n        &#125;\n        else\n        &#123;\n            ptail[v2]-&gt;next &#x3D; new node(v1, cs);\n            ptail[v2] &#x3D; ptail[v2]-&gt;next;\n        &#125;\n    &#125;\n    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)\n    &#123;\n        dist[i] &#x3D; INT32_MAX;\n    &#125;\n    dist[strt] &#x3D; 0;\n    list.push(edge(0, strt));\n    while (!list.empty())\n    &#123;\n        edge cur &#x3D; list.top();\n        list.pop();\n        if (vis[cur.val] &#x3D;&#x3D; 1)\n            continue;\n        else\n            vis[cur.val] &#x3D; 1;\n\n        node *t &#x3D; phead[cur.val];\n        while (t !&#x3D; nullptr)\n        &#123;\n            if (t-&gt;cost + dist[cur.val] &lt; dist[t-&gt;val])\n            &#123;\n                dist[t-&gt;val] &#x3D; t-&gt;cost + dist[cur.val];\n                list.push(edge(dist[t-&gt;val], t-&gt;val));\n                citycnt[t-&gt;val] &#x3D; citycnt[cur.val] + 1;\n            &#125;\n            else if (t-&gt;cost + dist[cur.val] &#x3D;&#x3D; dist[t-&gt;val])\n            &#123;\n                if (citycnt[t-&gt;val] &lt; citycnt[cur.val] + 1)\n                    citycnt[t-&gt;val] &#x3D; citycnt[cur.val] + 1;\n            &#125;\n            t &#x3D; t-&gt;next;\n        &#125;\n    &#125;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        cout &lt;&lt; dist[i];\n        if (i !&#x3D; n)\n            cout &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        cout &lt;&lt; citycnt[i];\n        if (i !&#x3D; n)\n            cout &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    return 0;\n&#125;</code></pre>\n\n<h2 id=\"第四题：供电\"><a href=\"#第四题：供电\" class=\"headerlink\" title=\"第四题：供电\"></a><strong>第四题：供电</strong></h2><p>给N个地区供电。每个地区或者建一个供电站，或者修一条线道连接到其它有电的地区。试确定给N个地区都供上电的最小费用。</p>\n<p>要给N个地区供电。每个地区或者建一个供电站，或者修一条线道连接到其它有电的地区。试确定给N个地区都供上电的最小费用。</p>\n<h3 id=\"输入格式-2\"><a href=\"#输入格式-2\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>第1行，两个个整数 N 和 M , 用空格分隔，分别表示地区数和修线路的方案数，1≤N≤10000，0≤M≤50000。</p>\n<p>第2行，包含N个用空格分隔的整数P[i]，表示在第i个地区建一个供电站的代价，1 ≤P[i]≤ 100,000，1≤i≤N 。</p>\n<p>接下来M行，每行3个整数a、b和c，用空格分隔，表示在地区a和b之间修一条线路的代价为c，1 ≤ c ≤ 100,000，1≤a,b≤N 。</p>\n<h3 id=\"输出格式-2\"><a href=\"#输出格式-2\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>一行，包含一个整数， 表示所求最小代价。</p>\n<h3 id=\"输入样例-2\"><a href=\"#输入样例-2\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">4 6\n5 4 4 3\n1 2 2\n1 3 2\n1 4 2\n2 3 3\n2 4 3\n3 4 4</code></pre>\n\n<h3 id=\"输出样例-2\"><a href=\"#输出样例-2\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">9</code></pre>\n\n<h3 id=\"题目解析-2\"><a href=\"#题目解析-2\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><p>最小生成树问题，但是可以选择自己供电，即本题的图，既有点权，又有边权。可以选择点权化边权，然后使用最小生成树的相关算法完成。</p>\n<h4 id=\"方法一：Kruskal\"><a href=\"#方法一：Kruskal\" class=\"headerlink\" title=\"方法一：Kruskal\"></a><strong>方法一：Kruskal</strong></h4><h5 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h5><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nint cost_sum &#x3D; 0;\n\nint pre[10001];\n\nint find(int x)\n&#123;\n    if(pre[x] &#x3D;&#x3D; x) return x;\n    return pre[x] &#x3D; find(pre[x]);\n&#125;\n\nvoid join(int x, int y)\n&#123;\n    int fx &#x3D; find(x), fy &#x3D; find(y);\n    if(fx !&#x3D; fy)\n        pre[fx] &#x3D; fy;\n&#125;\n\nstruct edge\n&#123;\n    int fr, to;\n    int cost;\n\n    bool operator &gt;(const edge &amp; b)const\n    &#123;\n        return cost &gt; b.cost;\n    &#125;\n&#125;;\n\npriority_queue&lt;edge,vector&lt;edge&gt;,greater&lt;edge&gt;&gt; list;\n\nint main()\n&#123;\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    pre[0] &#x3D; 0;\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        int tmp_cost;\n        cin &gt;&gt; tmp_cost;\n        edge *Edge &#x3D; new edge;\n        Edge-&gt;fr &#x3D; 0;\n        Edge-&gt;to &#x3D; i;\n        Edge-&gt;cost &#x3D; tmp_cost;\n        list.push(*Edge);\n        pre[i] &#x3D; i;\n    &#125;\n\n    for(int i &#x3D; 0 ; i&lt;&#x3D; m - 1 ; i++)\n    &#123;\n        int tmp_fr, tmp_to, tmp_cost;\n        cin &gt;&gt; tmp_fr &gt;&gt; tmp_to &gt;&gt; tmp_cost;\n        edge *Edge &#x3D; new edge;\n        Edge-&gt;fr &#x3D; tmp_fr;\n        Edge-&gt;to &#x3D; tmp_to;\n        Edge-&gt;cost &#x3D; tmp_cost;\n        list.push(*Edge);\n    &#125;\n    int T &#x3D; n + 1;\n    while(T &gt; 1)\n    &#123;\n        edge Edge &#x3D; list.top();\n        list.pop();\n        int vex1 &#x3D; Edge.fr;\n        int vex2 &#x3D; Edge.to;\n        int cost &#x3D; Edge.cost;\n        if(find(vex1) !&#x3D; find(vex2))\n        &#123;\n            cost_sum +&#x3D; cost;\n            join(vex1, vex2);\n            T--;\n        &#125;\n    &#125;\n    cout &lt;&lt; cost_sum &lt;&lt; endl;\n    return 0;\n&#125;</code></pre>\n","text":"第一题：连通分量无向图 G 有 n 个顶点和 m 条边。求 G 的连通分量的数目。 输入格式：第1行，2个整数n和m，用空格分隔，分别表示顶点数和边数， 1≤n≤50000， 1≤m≤100000. 第2到m+1行，每行两个整数u和v，用空格分隔，表示顶点u到顶点v有一条边，u和...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":6,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":14,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":6,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E9%A2%98%EF%BC%9A%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F\"><span class=\"toc-text\">第一题：连通分量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">输入格式：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">输出格式：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">输入样例：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-1\"><span class=\"toc-text\">输入样例：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90%EF%BC%9A\"><span class=\"toc-text\">题目解析：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">方法一：深度优先遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E5%85%A5%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89\"><span class=\"toc-text\">读入无向图（邻接表）</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#DFS\"><span class=\"toc-text\">DFS</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">完整代码</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86\"><span class=\"toc-text\">方法二：并查集</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%9A%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86\"><span class=\"toc-text\">第二题：整数拆分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%9B%9E%E6%BA%AF%E6%B3%95\"><span class=\"toc-text\">方法一：回溯法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1\"><span class=\"toc-text\">代码实现</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E9%A2%98%EF%BC%9A%E6%97%85%E8%A1%8C\"><span class=\"toc-text\">第三题：旅行</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-1\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-1\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-1\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ADijkstra\"><span class=\"toc-text\">方法一：Dijkstra</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2\"><span class=\"toc-text\">代码实现</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%9B%9B%E9%A2%98%EF%BC%9A%E4%BE%9B%E7%94%B5\"><span class=\"toc-text\">第四题：供电</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-2\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-2\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-2\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AKruskal\"><span class=\"toc-text\">方法一：Kruskal</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3\"><span class=\"toc-text\">代码实现</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"数据结构第四次上机实验","uid":"7d8e8db1d60b240c8f6df95f6b0082a1","slug":"数据结构第四次上机实验","date":"2022-09-06T04:00:18.000Z","updated":"2023-02-28T17:40:58.024Z","comments":true,"path":"api/articles/数据结构第四次上机实验.json","keywords":null,"cover":[],"text":"第一题： 图的深度优先搜索I无向图 G 有 n 个顶点和 m 条边。求图G的深度优先搜索树(森林)以及每个顶点的发现时间和完成时间。每个连通分量从编号最小的结点开始搜索，邻接顶点选择顺序遵循边的输入顺序。 在搜索过程中，第一次遇到一个结点，称该结点被发现；一个结点的所有邻接结点都...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":6,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":14,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":6,"path":"api/tags/数据结构.json"}],"author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"数据结构第二次上机实验","uid":"407b137722e04956b74ff31b7ce67773","slug":"数据结构第二次上机实验","date":"2022-09-06T03:30:53.000Z","updated":"2023-02-28T17:40:58.061Z","comments":true,"path":"api/articles/数据结构第二次上机实验.json","keywords":null,"cover":null,"text":"第一题：二叉树最长路径给定一棵二叉树T，求T中的最长路径的长度，并输出此路径上各结点的值。若有多条最长路径，输出最右侧的那条。 输入格式第1行，1个整数n，表示二叉树有n个结点， 1≤n≤100000. 第2行，2n+1个整数，用空格分隔，表示T的扩展先根序列， -1表示空指针，...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":6,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":14,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":6,"path":"api/tags/数据结构.json"}],"author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}