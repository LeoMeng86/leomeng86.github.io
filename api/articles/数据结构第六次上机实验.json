{"title":"数据结构第六次上机实验","uid":"92dcc63de0a91e6ef330681692883b4c","slug":"数据结构第六次上机实验","date":"2022-09-06T04:02:32.000Z","updated":"2023-02-28T17:40:59.563Z","comments":true,"path":"api/articles/数据结构第六次上机实验.json","keywords":null,"cover":null,"content":"<h2 id=\"第一题：稀疏矩阵之差\"><a href=\"#第一题：稀疏矩阵之差\" class=\"headerlink\" title=\"第一题：稀疏矩阵之差\"></a><strong>第一题：稀疏矩阵之差</strong></h2><p>矩阵A和B都是稀疏矩阵。请计算矩阵的差A-B.如果A、B不能计算差值，输出”Illegal!”</p>\n<h3 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>矩阵的输入采用三元组表示，先A后B。对每个矩阵：</p>\n<p>第1行，3个整数N、M、t，用空格分隔，分别表示矩阵的行数、列数和非0数据项数，10≤N、M≤50000，t≤min(N,M).</p>\n<p>第2至t+1行，每行3个整数r、c、v，用空格分隔，表示矩阵r行c列的位置是非0数据项v, v在32位有符号整型范围内。三元组默认按行列排序。</p>\n<h3 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>矩阵A-B，采用三元组表示，默认按行列排序，非零项也在32位有符号整型范围内。</p>\n<h3 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">10 10 3\n2 2 2\n5 5 5\n10 10 20\n10 10 2\n2 2 1\n6 6 6</code></pre>\n\n<h3 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">10 10 4\n2 2 1\n5 5 5\n6 6 -6\n10 10 20</code></pre>\n\n<h3 id=\"题目解析\"><a href=\"#题目解析\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><h4 id=\"方法一：归并\"><a href=\"#方法一：归并\" class=\"headerlink\" title=\"方法一：归并\"></a><strong>方法一：归并</strong></h4><p>注意到题目给出的三元组已经按照行列排序，且输出要求也要求按照行列顺序，这里使用一个归并的方法，如果第一个矩阵的三元组小于第二个的，直接储存第一个，如果相等，输出相减后储存，如果第二个矩阵的三元组位置较小，储存第二个矩阵的相反数。</p>\n<p>里面有一个坑，相减后可能出现0的情况，一旦出现结果零，即不储存。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint main()\n&#123;\n    int CNT;\n    vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; a, b, c;\n    int n, m, cnt;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; cnt;\n    CNT &#x3D; cnt;\n    while (cnt--)\n    &#123;\n        int tn, tm, val;\n        cin &gt;&gt; tn &gt;&gt; tm &gt;&gt; val;\n        auto tmp &#x3D; pair&lt;int, int&gt;(tn, tm);\n        a.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, val));\n    &#125;\n    int n2, m2, cnt2;\n    cin &gt;&gt; n2 &gt;&gt; m2 &gt;&gt; cnt2;\n    CNT +&#x3D; cnt2;\n    if (n2 !&#x3D; n || m !&#x3D; m2)\n    &#123;\n        cout &lt;&lt; &quot;Illegal!&quot;;\n        return 0;\n    &#125;\n    while (cnt2--)\n    &#123;\n        int tn, tm, val;\n        cin &gt;&gt; tn &gt;&gt; tm &gt;&gt; val;\n        auto tmp &#x3D; pair&lt;int, int&gt;(tn, tm);\n        b.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, val));\n    &#125;\n    auto t1 &#x3D; a.begin();\n    auto t2 &#x3D; b.begin();\n    while (t1 !&#x3D; a.end() &amp;&amp; t2 !&#x3D; b.end())\n    &#123;\n        if (t1-&gt;first.first &#x3D;&#x3D; t2-&gt;first.first)\n        &#123;\n            if (t2-&gt;first.second &#x3D;&#x3D; t1-&gt;first.second)\n            &#123;\n                auto tmp &#x3D; pair&lt;int, int&gt;(t1-&gt;first.first, t1-&gt;first.second);\n                if (t1-&gt;second - t2-&gt;second !&#x3D; 0)\n                    c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, t1-&gt;second - t2-&gt;second));\n                else\n                &#123;\n                    CNT--;\n                &#125;\n                t1++, t2++;\n                CNT--;\n            &#125;\n            else if (t1-&gt;first.second &lt; t2-&gt;first.second)\n            &#123;\n                auto tmp &#x3D; pair&lt;int, int&gt;(t1-&gt;first.first, t1-&gt;first.second);\n                c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, t1-&gt;second));\n                t1++;\n            &#125;\n            else if (t1-&gt;first.second &gt; t2-&gt;first.second)\n            &#123;\n                auto tmp &#x3D; pair&lt;int, int&gt;(t2-&gt;first.first, t2-&gt;first.second);\n                c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, -t2-&gt;second));\n                t2++;\n            &#125;\n        &#125;\n        else if (t1-&gt;first.first &lt; t2-&gt;first.first)\n        &#123;\n            auto tmp &#x3D; pair&lt;int, int&gt;(t1-&gt;first.first, t1-&gt;first.second);\n            c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, t1-&gt;second));\n            t1++;\n        &#125;\n        else if (t1-&gt;first.first &gt; t2-&gt;first.first)\n        &#123;\n            auto tmp &#x3D; pair&lt;int, int&gt;(t2-&gt;first.first, t2-&gt;first.second);\n            c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, -t2-&gt;second));\n            t2++;\n        &#125;\n    &#125;\n    while (t2 !&#x3D; b.end())\n    &#123;\n        auto tmp &#x3D; pair&lt;int, int&gt;(t2-&gt;first.first, t2-&gt;first.second);\n        c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, -t2-&gt;second));\n        t2++;\n    &#125;\n    while (t1 !&#x3D; a.end())\n    &#123;\n        auto tmp &#x3D; pair&lt;int, int&gt;(t1-&gt;first.first, t1-&gt;first.second);\n        c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, t1-&gt;second));\n        t1++;\n    &#125;\n    auto it &#x3D; c.begin();\n    cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; CNT &lt;&lt; &quot;\\n&quot;;\n    while (it !&#x3D; c.end())\n    &#123;\n        cout &lt;&lt; it-&gt;first.first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;first.second &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second;\n        if (it + 1 !&#x3D; c.end())\n            cout &lt;&lt; &quot;\\n&quot;;\n        it++;\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h2 id=\"第二题：二叉树的最短路径长\"><a href=\"#第二题：二叉树的最短路径长\" class=\"headerlink\" title=\"第二题：二叉树的最短路径长\"></a><strong>第二题：二叉树的最短路径长</strong></h2><p>给定一棵二叉树T，每个结点赋一个权值。计算从根结点到所有结点的最短路径长度。路径长度定义为：路径上的每个顶点的权值和。</p>\n<h3 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>第1行，1个整数n，表示二叉树T的结点数，结点编号1..n，1≤n≤20000。</p>\n<p>第2行，n个整数，空格分隔，表示T的先根序列，序列中结点用编号表示。</p>\n<p>第3行，n个整数，空格分隔，表示T的中根序列，序列中结点用编号表示。</p>\n<p>第4行，n个整数Wi，空格分隔，表示T中结点的权值，-10000≤Wi≤10000，1≤i≤n。</p>\n<h3 id=\"输出格式-1\"><a href=\"#输出格式-1\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>1行，n个整数，表示根结点到其它所有结点的最短路径长度。</p>\n<h3 id=\"输入样例-1\"><a href=\"#输入样例-1\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">4\n1 2 4 3\n4 2 1 3\n1 -1 2 3</code></pre>\n\n<h3 id=\"输出样例-1\"><a href=\"#输出样例-1\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">1 0 3 3</code></pre>\n\n<h3 id=\"题目解析-1\"><a href=\"#题目解析-1\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><p>使用中根序列和先跟序列递归建树，然后DFS更新每个节点的最短路径长度。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nint _val[20001];\nint result[20001] &#x3D; &#123;0&#125;;\n\nstruct node\n&#123;\n    int val;\n    node *left;\n    node *right;\n&#125;;\n\nnode *build(int *pre, int *in, int size)\n&#123;\n    if (size &lt;&#x3D; 0)\n        return nullptr;\n\n    int i;\n    for (i &#x3D; 0; i &lt;&#x3D; size - 1; i++)\n    &#123;\n        if (in[i] &#x3D;&#x3D; pre[0])\n            break;\n    &#125;\n\n    node *tree &#x3D; new node;\n    tree-&gt;val &#x3D; pre[0];\n    tree-&gt;left &#x3D; build(pre + 1, in, i);\n    tree-&gt;right &#x3D; build(pre + i + 1, in + i + 1, size - 1 - i);\n    return tree;\n&#125;\n\nvoid DFS(node * root, int cost)\n&#123;\n    if(root &#x3D;&#x3D; nullptr) return;\n    result[root-&gt;val] &#x3D; cost + _val[root-&gt;val];\n    DFS(root-&gt;left, result[root-&gt;val]);\n    DFS(root-&gt;right, result[root-&gt;val]);\n&#125;\n\nint main()\n&#123;\n    int n;\n    scanf(&quot;%d&quot;, &amp;n);\n    int _pre[20001], _in[20001];\n\n    for(int i &#x3D; 0; i &lt;&#x3D; n - 1; i++)\n    &#123;\n        scanf(&quot;%d&quot;, &amp;_pre[i]);\n    &#125;\n\n    for(int i &#x3D; 0; i &lt;&#x3D; n - 1; i++)\n    &#123;\n        scanf(&quot;%d&quot;, &amp;_in[i]);\n    &#125;\n\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        scanf(&quot;%d&quot;, &amp;_val[i]);\n    &#125;\n\n    node* root &#x3D; build(_pre,_in,n);\n\n    DFS(root, 0);\n\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        printf(&quot;%d&quot;, result[i]);\n        if(i !&#x3D; n) printf(&quot; &quot;);\n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;</code></pre>\n\n<h2 id=\"第三题：文字编辑\"><a href=\"#第三题：文字编辑\" class=\"headerlink\" title=\"第三题：文字编辑\"></a><strong>第三题：文字编辑</strong></h2><p>一篇文章由n个汉字构成，汉字从前到后依次编号为1，2，……，n。有四种操作：</p>\n<p>A i j表示把编号为i的汉字移动编号为j的汉字之前；</p>\n<p>B i j表示把编号为i的汉字移动编号为j的汉字之后；</p>\n<p>Q 0 i为询问编号为i的汉字之前的汉字的编号；</p>\n<p>Q 1 i为询问编号为i的汉字之后的汉字的编号。</p>\n<p>规定：1号汉字之前是n号汉字，n号汉字之后是1号汉字。</p>\n<h3 id=\"输入格式-2\"><a href=\"#输入格式-2\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>第1行，1个整数T，表示有T组测试数据， 1≤T≤9999.</p>\n<p>随后的每一组测试数据中，第1行两个整数n和m，用空格分隔，分别代表汉字数和操作数，2≤n≤9999，1≤m≤9999；第2至m+1行，每行包含3个常量s、i和j，用空格分隔，s代表操作的类型，若s为A或B，则i和j表示汉字的编号，若s为Q，i代表0或1，j代表汉字的编号。</p>\n<h3 id=\"输出格式-2\"><a href=\"#输出格式-2\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>若干行，每行1个整数，对应每个询问的结果汉字编号。</p>\n<h3 id=\"输入样例-2\"><a href=\"#输入样例-2\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">1\n9999 4\nB 1 2\nA 3 9999\nQ 1 1\nQ 0 3</code></pre>\n\n<h3 id=\"输出样例-2\"><a href=\"#输出样例-2\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">4\n9998</code></pre>\n\n<h3 id=\"题目解析-2\"><a href=\"#题目解析-2\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><h4 id=\"方法一：跳舞链\"><a href=\"#方法一：跳舞链\" class=\"headerlink\" title=\"方法一：跳舞链\"></a><strong>方法一：跳舞链</strong></h4><p>实现定点插入，定点查询，定点删除，且能满足1000ms的时间限制，使用跳舞链会比较合适。</p>\n<p>本题使用静态链表实现，会比较好写。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint main()\n&#123;\n    int T;\n    scanf(&quot;%d&quot;, &amp;T);\n    int pre[100001];\n    int nxt[100001];\n    int n, m;\n    for (register int j &#x3D; 0; j &lt;&#x3D; T - 1; j++)\n    &#123;\n        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n        for (register int i &#x3D; 1; i &lt;&#x3D; n; i++)\n        &#123;\n\n            pre[i] &#x3D; i - 1;\n            nxt[i] &#x3D; i + 1;\n        &#125;\n        pre[1] &#x3D; n;\n        nxt[n] &#x3D; 1;\n        for (register int k &#x3D; 0; k &lt;&#x3D; m - 1; k++)\n        &#123;\n            char ch;\n            int op1, op2;\n            cin &gt;&gt; ch;\n            scanf(&quot;%d%d&quot;, &amp;op1, &amp;op2);\n            switch (ch)\n            &#123;\n            case &#39;A&#39;:\n            &#123;\n                nxt[pre[op1]] &#x3D; nxt[op1];\n                pre[nxt[op1]] &#x3D; pre[op1];\n                pre[op1] &#x3D; pre[op2];\n                nxt[op1] &#x3D; op2;\n                nxt[pre[op2]] &#x3D; op1;\n                pre[op2] &#x3D; op1;\n                break;\n            &#125;\n            case &#39;B&#39;:\n            &#123;\n                nxt[pre[op1]] &#x3D; nxt[op1];\n                pre[nxt[op1]] &#x3D; pre[op1];\n                pre[op1] &#x3D; op2;\n                nxt[op1] &#x3D; nxt[op2];\n                pre[nxt[op2]] &#x3D; op1;\n                nxt[op2] &#x3D; op1;\n                break;\n            &#125;\n            case &#39;Q&#39;:\n            &#123;\n                switch (op1)\n                &#123;\n                case 0:\n                &#123;\n                    printf(&quot;%d\\n&quot;, pre[op2]);\n                    break;\n                &#125;\n                case 1:\n                &#123;\n                    printf(&quot;%d\\n&quot;, nxt[op2]);\n                    break;\n                &#125;\n                &#125;\n                break;\n            &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"第四题：方案计数\"><a href=\"#第四题：方案计数\" class=\"headerlink\" title=\"第四题：方案计数\"></a><strong>第四题：方案计数</strong></h2><p>组装一个产品需要 n 个零件。生产每个零件都需花费一定的时间。零件的生产可以并行进行。有些零件的生产有先后关系，只有一个零件的之前的所有零件都生产完毕，才能开始生产这个零件。如何合理安排工序，才能在最少的时间内完成所有零件的生产。在保证最少时间情况下，关键方案有多少种，关键方案是指从生产开始时间到结束时间的一个零件生产序列，序列中相邻两个零件的关系属于事先给出的零件间先后关系的集合，序列中的每一个零件的生产都不能延期。</p>\n<h3 id=\"输入格式-3\"><a href=\"#输入格式-3\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>第1行，2个整数n和m，用空格分隔，分别表示零件数和关系数，零件编号1..n，1≤n≤10000, 0≤m≤100000 。</p>\n<p>第2行，n个整数Ti，用空格分隔，表示零件i的生产时间，1≤i≤n，1≤Ti≤100 。</p>\n<h3 id=\"输出格式-3\"><a href=\"#输出格式-3\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>第1行，1个整数，完成生产的最少时间。</p>\n<p>第2行，1个整数，关键方案数，最多100位。</p>\n<p>如果生产不能完成，只输出1行，包含1个整数0.</p>\n<h3 id=\"输入样例-3\"><a href=\"#输入样例-3\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">4 4\n1 2 2 1\n1 2\n1 3\n2 4\n3 4</code></pre>\n\n<h3 id=\"输出样例-3\"><a href=\"#输出样例-3\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">4\n2</code></pre>\n\n<h3 id=\"题目解析-3\"><a href=\"#题目解析-3\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><h4 id=\"方法一：拓扑排序-关键路径-高精度\"><a href=\"#方法一：拓扑排序-关键路径-高精度\" class=\"headerlink\" title=\"方法一：拓扑排序+关键路径+高精度\"></a><strong>方法一：拓扑排序+关键路径+高精度</strong></h4><p>感谢mxgg，上次有一个题目一直段错误，mxgg发现是我爆了int，建议我以后#define int long long, 我说以后不是BigInteger我都不用，然后就机缘巧合向大佬学习写了BigInt的板子，mxgg yyds！！！</p>\n<p>除了需要高精度，读图时候，需要点权推到边权上，并把入度为0的点引到虚源，出度为0的点汇到虚源上，形成连通图，然后拓扑排序和关键路径算法。</p>\n<p>对于我这种蒟蒻，存板子就是我白月光！！！膜拜手拍大佬！！！</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;limits&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nclass Bigint\n&#123;\nprivate:\n    vector&lt;int&gt; content;\npublic:\n    Bigint();\n    Bigint(long long origin);\n    Bigint(const Bigint&amp; b);\n    ~Bigint();\n    unsigned long long size() const;\n    Bigint operator+(const Bigint&amp; b);\n    Bigint&amp; operator&#x3D;(const Bigint&amp; b);\n    void resize(unsigned long long n);\n    const int&amp; operator[](unsigned long long i)const;\n    int&amp; operator[](unsigned long long i);\n    string toString();\n&#125;;\n\nBigint::Bigint()&#123;\n    content.reserve(128);\n    for (int i &#x3D; 0; i &lt; 128; ++i)&#123;\n        content.push_back(0);\n    &#125;\n\n&#125;\n\nBigint::Bigint(long long origin)&#123;\n    content.reserve(128);\n    while (origin&gt;0)\n    &#123;\n        content.push_back(origin%10);\n        origin&#x3D;origin&#x2F;10;\n    &#125;\n&#125;\nBigint::Bigint(const Bigint&amp; b)&#123;\n    content.clear();\n    for(int i&#x3D;0;i&lt;b.size();++i)&#123;\n        content.push_back(b[i]);\n    &#125;\n&#125;\n\nBigint::~Bigint()&#123;\n    content.clear();\n&#125;\n\nBigint Bigint::operator+(const Bigint&amp; b)&#123;\n    Bigint t;\n    Bigint res;\n    unsigned long long maxsize&#x3D;max(this-&gt;size(),b.size());\n    t.resize(maxsize+1);\n    res.resize(maxsize+1);\n    for (int i &#x3D; 0; i &lt; maxsize; ++i)&#123;\n        int num1&#x3D;i&lt;this-&gt;size()?content[i]:0;\n        int num2&#x3D;i&lt;b.size()?b[i]:0;\n        res[i]&#x3D;(num1+num2+t[i])%10;\n        t[i+1]&#x3D;(num1+num2+t[i])&#x2F;10;\n    &#125;\n    if(t[maxsize]!&#x3D;0)&#123;\n        res[maxsize]&#x3D;t[maxsize];\n    &#125;else&#123;\n        res.resize(maxsize);\n    &#125;\n    return res;\n&#125;\n\nBigint&amp; Bigint::operator&#x3D;(const Bigint&amp; b)&#123;\n    if(this&#x3D;&#x3D;&amp;b)&#123;\n        return *this;\n    &#125;else&#123;\n        content.clear();\n        content.reserve(b.size());\n        for(int i&#x3D;0;i&lt;b.size();++i)&#123;\n            content.push_back(b[i]);\n        &#125;\n    &#125;\n    return *this;\n&#125;\n\nunsigned long long Bigint::size()const&#123;\n        return content.size();\n&#125;\n\nconst int&amp; Bigint::operator[](unsigned long long i)const&#123;\n    if(i&gt;content.size())return *content.end();\n    return (*(content.begin()+i));\n&#125;\n\nint&amp; Bigint::operator[](unsigned long long i)&#123;\n    if(i&gt;content.size())return *content.end();\n    return (*(content.begin()+i));\n&#125;\n\nvoid Bigint::resize(unsigned long long n)&#123;\n    if(n&gt;this-&gt;size())&#123;\n        for (unsigned long long i &#x3D; this-&gt;size(); i &lt;n; ++i)&#123;\n            content.push_back(0);\n        &#125;\n    &#125;else&#123;\n        for (unsigned long long i &#x3D; this-&gt;size(); i&gt;n; --i)&#123;\n            content.pop_back();\n        &#125;\n    &#125;\n&#125;\n\nstring Bigint::toString()&#123;\n    bool flag&#x3D;true;\n    string res;\n    for (int i &#x3D; this-&gt;size()-1; i &gt;&#x3D;0; --i)&#123;\n        if(flag&amp;&amp;content[i]&#x3D;&#x3D;0)&#123;\n            continue;\n        &#125;else&#123;\n            if(flag&amp;&amp;content[i]!&#x3D;0)&#123;\n                flag&#x3D;false;\n            &#125;\n            res.push_back(content[i]+48);\n        &#125;\n    &#125;\n    if(flag)res.push_back(&#39;0&#39;);\n    return res;\n&#125;\n\nconst int maxn &#x3D; 10010;\nint n &#x3D; 0, m &#x3D; 0;\n\nint inDu[maxn] &#x3D; &#123;0&#125;;\nint inDu_bfs[maxn] &#x3D; &#123;0&#125;;\nint outDu[maxn] &#x3D; &#123;0&#125;;\nint es[maxn] &#x3D; &#123;0&#125;;\nint ls[maxn];\nint cs[maxn] &#x3D; &#123;0&#125;;\n\nstruct Node\n&#123;\n    Node* nxt;\n    int val;\n    int cost;\n    Node(int _val &#x3D; 0, int _cost &#x3D; 0)\n    &#123;\n        cost &#x3D; _cost;\n        val &#x3D; _val;\n        nxt &#x3D; nullptr;\n    &#125;\n&#125;;\n\nNode *phead[maxn] &#x3D; &#123;nullptr&#125;, *ptail[maxn] &#x3D; &#123;nullptr&#125;;\n\nvoid add(int _fr, int _to, int _cost)\n&#123;\n    Node *t &#x3D; ptail[_fr];\n    if (t &#x3D;&#x3D; nullptr)\n    &#123;\n        phead[_fr] &#x3D; new Node(_to,_cost);\n        ptail[_fr] &#x3D; phead[_fr];\n    &#125;\n    else\n    &#123;\n        ptail[_fr]-&gt;nxt &#x3D; new Node(_to, _cost);\n        ptail[_fr] &#x3D; ptail[_fr]-&gt;nxt;\n    &#125;\n    outDu[_fr]++;\n    inDu[_to]++;\n    inDu_bfs[_to]++;\n\n&#125;\n\nvoid read_map()\n&#123;\n    for(int i &#x3D; 1; i &lt;&#x3D; n ; i++)\n    &#123;\n        scanf(&quot;%d&quot;, &amp;cs[i]);\n    &#125;\n    int _fr &#x3D; 0, _to &#x3D; 0;\n    for(int i  &#x3D; 0; i &lt;&#x3D; m - 1; i++)\n    &#123;\n        scanf(&quot;%d%d&quot;, &amp;_fr, &amp;_to);\n        add(_fr, _to, cs[_to]);\n    &#125;\n\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        if(inDu[i] &#x3D;&#x3D; 0)\n        &#123;\n            add(0,i,cs[i]);\n        &#125;\n        if(outDu[i] &#x3D;&#x3D; 0)\n        &#123;\n            add(i, n + 1, 0);\n        &#125;\n    &#125;\n&#125;\n\nvector&lt;int&gt; topo_result;\nvoid topo()\n&#123;\n    queue&lt;int&gt; q;\n    topo_result.reserve(maxn);\n    q.push(0);\n    while(!q.empty())\n    &#123;\n        int now &#x3D; q.front();\n        q.pop();\n        topo_result.push_back(now);\n        for(auto it &#x3D; phead[now]; it!&#x3D; nullptr; it&#x3D; it-&gt;nxt)\n        &#123;\n            int to &#x3D; it-&gt;val;\n            int cost &#x3D; it-&gt;cost;\n            inDu[to]--;\n            if(inDu[to] &#x3D;&#x3D; 0)\n            &#123;\n                q.push(to);\n            &#125;\n            es[to] &#x3D; max(es[now] + cost, es[to]);\n        &#125;\n    &#125;\n&#125;\n\nvoid Cpath()\n&#123;\n    topo();\n    ls[n+1] &#x3D; es[n+1];\n    for(int i &#x3D; topo_result.size() - 1; i &gt;&#x3D; 0; i--)\n    &#123;\n        int now &#x3D; topo_result[i];\n        for(auto it &#x3D; phead[now]; it !&#x3D; nullptr; it &#x3D; it-&gt;nxt)\n        &#123;\n            int to &#x3D; it-&gt;val;\n            int cost &#x3D; it-&gt;cost;\n            ls[now] &#x3D; min(ls[to]-cost, ls[now]);\n        &#125;\n    &#125;\n&#125;\n\nBigint tmp[maxn];\nBigint res;\nint vis[maxn] &#x3D; &#123;0&#125;;\n\nvoid bfs(int x)\n&#123;\n    queue&lt;int&gt; q;\n    q.push(x);\n    vis[x] &#x3D; 1;\n    while(!q.empty())\n    &#123;\n        int now &#x3D; q.front();\n        q.pop();\n        vis[now] &#x3D; 1;\n        for(auto it &#x3D; phead[now]; it !&#x3D; nullptr; it &#x3D; it-&gt;nxt)\n        &#123;\n            int to &#x3D; it-&gt;val;\n            inDu_bfs[to]--;\n            if(es[to] &#x3D;&#x3D; ls[to])\n            &#123;\n                tmp[to] &#x3D; tmp[now] + tmp[to];\n            &#125;\n            if(inDu_bfs[to] &#x3D;&#x3D; 0)\n            &#123;\n                q.push(to);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    for(int i &#x3D; 0; i &lt;&#x3D; maxn - 1; i++)\n    &#123;\n        ls[i] &#x3D; INT32_MAX;\n    &#125;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    read_map();\n    Cpath();\n    tmp[0] &#x3D; 1;\n    bfs(0);\n    long long result &#x3D; es[n+1];\n    res &#x3D; tmp[n+1];\n    if(res.toString() !&#x3D; &quot;0&quot;) cout &lt;&lt; result &lt;&lt;endl;\n    cout &lt;&lt; res.toString() &lt;&lt; endl;\n    return 0;\n&#125;</code></pre>","text":"第一题：稀疏矩阵之差矩阵A和B都是稀疏矩阵。请计算矩阵的差A-B.如果A、B不能计算差值，输出”Illegal!” 输入格式矩阵的输入采用三元组表示，先A后B。对每个矩阵： 第1行，3个整数N、M、t，用空格分隔，分别表示矩阵的行数、列数和非0数据项数，10≤N、M≤50000，...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":7,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":15,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":7,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E9%A2%98%EF%BC%9A%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B9%8B%E5%B7%AE\"><span class=\"toc-text\">第一题：稀疏矩阵之差</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%BD%92%E5%B9%B6\"><span class=\"toc-text\">方法一：归并</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%95%BF\"><span class=\"toc-text\">第二题：二叉树的最短路径长</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-1\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-1\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-1\"><span class=\"toc-text\">题目解析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E9%A2%98%EF%BC%9A%E6%96%87%E5%AD%97%E7%BC%96%E8%BE%91\"><span class=\"toc-text\">第三题：文字编辑</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-2\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-2\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-2\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%B7%B3%E8%88%9E%E9%93%BE\"><span class=\"toc-text\">方法一：跳舞链</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%9B%9B%E9%A2%98%EF%BC%9A%E6%96%B9%E6%A1%88%E8%AE%A1%E6%95%B0\"><span class=\"toc-text\">第四题：方案计数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-3\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-3\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-3\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-3\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-3\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84-%E9%AB%98%E7%B2%BE%E5%BA%A6\"><span class=\"toc-text\">方法一：拓扑排序+关键路径+高精度</span></a></li></ol></li></ol></li></ol>","author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"数据结构第七次上机实验","uid":"82c87e7d3d5a50c5b7d55245f7119e74","slug":"数据结构第七次上机实验","date":"2022-09-06T04:32:32.000Z","updated":"2023-02-28T17:40:59.499Z","comments":true,"path":"api/articles/数据结构第七次上机实验.json","keywords":null,"cover":null,"text":"第一题：序列调度有一个N个数的序列A：1，2，……，N。有一个后进先出容器D，容器的容量为C。如果给出一个由1到N组成的序列，那么可否由A使用容器D的插入和删除操作得到。 输入格式第1行，2个整数T和C，空格分隔，分别表示询问的组数和容器的容量，1≤T≤10，1≤C≤N。 第2到...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":7,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":15,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":7,"path":"api/tags/数据结构.json"}],"author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"数据结构第五次上机实验","uid":"11dfa7e5794f08feee18d1b7215f1a65","slug":"数据结构第五次上机实验","date":"2022-09-06T04:02:18.000Z","updated":"2023-02-28T17:40:56.663Z","comments":true,"path":"api/articles/数据结构第五次上机实验.json","keywords":null,"cover":null,"text":"第一题：重复计数在一个有限的正整数序列中，有些数会多次重复出现。请你统计每个数的出现次数，然后按数字在序列中第一次出现的位置顺序输出数及其次数。 输入格式第1行，1个整数N，表示整数的个数，(1≤N≤50000)。 第2行，N个正整数，每个整数x 都满足 1 ≤ x ≤20000...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":7,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":15,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":7,"path":"api/tags/数据结构.json"}],"author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}