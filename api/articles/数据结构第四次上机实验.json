{"title":"数据结构第四次上机实验","uid":"7d8e8db1d60b240c8f6df95f6b0082a1","slug":"数据结构第四次上机实验","date":"2022-09-06T04:00:18.000Z","updated":"2023-02-28T17:40:58.024Z","comments":true,"path":"api/articles/数据结构第四次上机实验.json","keywords":null,"cover":[],"content":"<h2 id=\"第一题：-图的深度优先搜索I\"><a href=\"#第一题：-图的深度优先搜索I\" class=\"headerlink\" title=\"第一题： 图的深度优先搜索I\"></a><strong>第一题： 图的深度优先搜索I</strong></h2><p>无向图 G 有 n 个顶点和 m 条边。求图G的深度优先搜索树(森林)以及每个顶点的发现时间和完成时间。每个连通分量从编号最小的结点开始搜索，邻接顶点选择顺序遵循边的输入顺序。</p>\n<p>在搜索过程中，第一次遇到一个结点，称该结点被发现；一个结点的所有邻接结点都搜索完，该结点的搜索被完成。深度优先搜索维护一个时钟，时钟从0开始计数，结点被搜索发现或完成时，时钟计数增1，然后为当前结点盖上时间戳。一个结点被搜索发现和完成的时间戳分别称为该结点的发现时间和完成时间</p>\n<h3 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>第1行，2个整数n和m，用空格分隔，分别表示顶点数和边数， 1≤n≤50000， 1≤m≤100000.</p>\n<p>第2到m+1行，每行两个整数u和v，用空格分隔，表示顶点u到顶点v有一条边，u和v是顶点编号，1≤u,v≤n.</p>\n<h3 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>第1到n行，每行两个整数di和fi，用空格分隔，表示第i个顶点的发现时间和完成时间1≤i≤n 。</p>\n<p>第n+1行，1个整数 k ，表示图的深度优先搜索树(森林)的边数。</p>\n<p>第n+2到n+k+1行，每行两个整数u和v,表示深度优先搜索树(森林)的一条边&lt;u,v&gt;，边的输出顺序按 v 结点编号从小到大。</p>\n<h3 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">6 5\n1 3\n1 2\n2 3\n4 5\n5 6</code></pre>\n\n<h3 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">1 6\n3 4\n2 5\n7 12\n8 11\n9 10\n4\n3 2\n1 3\n4 5\n5 6</code></pre>\n\n<h3 id=\"题目解析\"><a href=\"#题目解析\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><h4 id=\"方法一：深度优先遍历\"><a href=\"#方法一：深度优先遍历\" class=\"headerlink\" title=\"方法一：深度优先遍历\"></a><strong>方法一：深度优先遍历</strong></h4><p>根据题目说的用DFS，使用一个timer来标识时间，然后用数组存每一个节点的进入时间和离开时间。</p>\n<h5 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h5><h6 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h6><p>每个DFS的点要用用vis数组标志访问情况，然后用timer给intime赋值，该节点遍历完成后，再用timer给outtime赋值。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void dfs(int x)\n&#123;\n    vis[x] &#x3D; 1;\n    intime[x] &#x3D; ++timer;\n\n    node *p &#x3D; phead[x];\n\n    while(p !&#x3D; nullptr)\n    &#123;\n        if(vis[p-&gt;val] !&#x3D; 1)\n        &#123;\n            list.push(edge(x,p-&gt;val));\n            dfs(p-&gt;val);\n        &#125;\n        p &#x3D; p-&gt;next;\n    &#125;\n\n    outtime[x] &#x3D; ++timer;\n&#125;</code></pre>\n\n<h6 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h6><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nint timer &#x3D; 0;\nint intime[50001] &#x3D; &#123;0&#125;, outtime[50001] &#x3D; &#123;0&#125;;\nint n, m, v1, v2;\nint vis[50001] &#x3D; &#123;0&#125;;\n\nclass node\n&#123;\npublic:\n    int val;\n    node *next;\n    node(int _v)\n    &#123;\n        val &#x3D; _v;\n        next &#x3D; nullptr;\n    &#125;\n&#125;;\n\nnode *phead[50001] &#x3D; &#123;nullptr&#125;;\nnode *ptail[50001] &#x3D; &#123;nullptr&#125;;\n\nclass edge\n&#123;\npublic:\n    int u, v;\n    edge(int u_tmp, int v_tmp) : u(u_tmp), v(v_tmp)&#123;&#125;;\n    bool operator&lt;(const edge &amp;b) const\n    &#123;\n        return v &gt; b.v;\n    &#125;\n&#125;;\n\npriority_queue&lt;edge&gt; list;\n\nvoid add(int &amp;a, int &amp;b)\n&#123;\n    node *t &#x3D; ptail[a];\n    if (t &#x3D;&#x3D; nullptr)\n    &#123;\n        phead[v1] &#x3D; new node(v2);\n        ptail[v1] &#x3D; phead[v1];\n    &#125;\n    else\n    &#123;\n        ptail[v1]-&gt;next &#x3D; new node(v2);\n        ptail[v1] &#x3D; ptail[v1]-&gt;next;\n    &#125;\n\n    t &#x3D; ptail[v2];\n    if (t &#x3D;&#x3D; nullptr)\n    &#123;\n        phead[v2] &#x3D; new node(v1);\n        ptail[v2] &#x3D; phead[v2];\n    &#125;\n    else\n    &#123;\n        ptail[v2]-&gt;next &#x3D; new node(v1);\n        ptail[v2] &#x3D; ptail[v2]-&gt;next;\n    &#125;\n&#125;\n\nvoid dfs(int x)\n&#123;\n    vis[x] &#x3D; 1;\n    intime[x] &#x3D; ++timer;\n\n    node *p &#x3D; phead[x];\n\n    while (p !&#x3D; nullptr)\n    &#123;\n        if (vis[p-&gt;val] !&#x3D; 1)\n        &#123;\n            list.push(edge(x, p-&gt;val));\n            dfs(p-&gt;val);\n        &#125;\n        p &#x3D; p-&gt;next;\n    &#125;\n\n    outtime[x] &#x3D; ++timer;\n&#125;\n\nint main()\n&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\n    for (int i &#x3D; 0; i &lt;&#x3D; m - 1; i++)\n    &#123;\n        scanf(&quot;%d%d&quot;, &amp;v1, &amp;v2);\n        add(v1, v2);\n    &#125;\n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        if (vis[i] !&#x3D; 1)\n        &#123;\n            dfs(i);\n        &#125;\n    &#125;\n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        printf(&quot;%d %d\\\\n&quot;, intime[i], outtime[i]);\n    &#125;\n    cout &lt;&lt; list.size() &lt;&lt; endl;\n    while (!list.empty())\n    &#123;\n        printf(&quot;%d %d\\\\n&quot;, list.top().u, list.top().v);\n        list.pop();\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"教训\"><a href=\"#教训\" class=\"headerlink\" title=\"教训\"></a><strong>教训</strong></h3><p>把各个函数都改了一遍，发现oj居然卡cin和cout，不要用cin或者cout还有endl，会变得不幸。</p>\n<h2 id=\"第二题：数字变换\"><a href=\"#第二题：数字变换\" class=\"headerlink\" title=\"第二题：数字变换\"></a><strong>第二题：数字变换</strong></h2><p>利用变换规则，一个数可以变换成另一个数。变换规则如下：（1）x 变为x+1；（2）x 变为2x；（3）x 变为 x-1。给定两个数x 和 y，至少经过几步变换能让 x 变换成 y.</p>\n<h3 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>1行，2个整数x和y，用空格分隔， 1≤x,y≤100000.</p>\n<h3 id=\"输出格式-1\"><a href=\"#输出格式-1\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>第1行，1个整数s，表示变换的最小步数。</p>\n<p>第2行，s个数，用空格分隔，表示最少变换时每步变换的结果。规则使用优先级顺序: （1），（2），（3）。</p>\n<h3 id=\"输入样例-1\"><a href=\"#输入样例-1\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">2 14</code></pre>\n\n<h3 id=\"输出样例-1\"><a href=\"#输出样例-1\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">4\n3 6 7 14</code></pre>\n\n<h3 id=\"题目解析-1\"><a href=\"#题目解析-1\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><p>无权无限图最短路问题，为防止两种不同步骤产生相同答案的重复计算，使用vis数组标志已访问变量，答案用path数组记录，输出时是逆序，应使用stack存储后，正序输出。</p>\n<h4 id=\"方法一：广度优先遍历\"><a href=\"#方法一：广度优先遍历\" class=\"headerlink\" title=\"方法一：广度优先遍历\"></a><strong>方法一：广度优先遍历</strong></h4><h5 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h5><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void bfs(int x, int y)\n&#123;\n    queue&lt;int&gt; q;\n    q.push(x);\n    while(!q.empty())\n    &#123;\n        int tmp &#x3D; q.front();\n        q.pop();\n        if(tmp + 1 &lt;&#x3D; maxn &amp;&amp; path[tmp+1] &#x3D;&#x3D; tmp + 1)\n        &#123;\n            q.push(tmp + 1);\n            path[tmp + 1] &#x3D; tmp;\n            if(tmp + 1 &#x3D;&#x3D; y) return;\n        &#125;\n        if(tmp * 2 &lt;&#x3D; maxn &amp;&amp; path[tmp * 2] &#x3D;&#x3D; tmp * 2)\n        &#123;\n            q.push(tmp *2);\n            path[tmp* 2] &#x3D; tmp;\n            if(tmp * 2 &#x3D;&#x3D; y) return;\n        &#125;\n        if(tmp - 1 &gt; 0 &amp;&amp; tmp - 1 &lt;&#x3D; maxn &amp;&amp; path[tmp -1] &#x3D;&#x3D; tmp -1)\n        &#123;\n            q.push(tmp - 1);\n            path[tmp - 1] &#x3D; tmp;\n            if(tmp - 1 &#x3D;&#x3D; y) return;\n        &#125;\n\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;stack&gt;\n#include&lt;queue&gt;\nusing namespace std;\n\nconst int maxn &#x3D; 100010;\nint path[maxn] &#x3D; &#123;0&#125;;\n\nvoid bfs(int x, int y)\n&#123;\n    queue&lt;int&gt; q;\n    q.push(x);\n    while(!q.empty())\n    &#123;\n        int tmp &#x3D; q.front();\n        q.pop();\n        if(tmp + 1 &lt;&#x3D; maxn &amp;&amp; path[tmp+1] &#x3D;&#x3D; tmp + 1)\n        &#123;\n            q.push(tmp + 1);\n            path[tmp + 1] &#x3D; tmp;\n            if(tmp + 1 &#x3D;&#x3D; y) return;\n        &#125;\n        if(tmp * 2 &lt;&#x3D; maxn &amp;&amp; path[tmp * 2] &#x3D;&#x3D; tmp * 2)\n        &#123;\n            q.push(tmp *2);\n            path[tmp* 2] &#x3D; tmp;\n            if(tmp * 2 &#x3D;&#x3D; y) return;\n        &#125;\n        if(tmp - 1 &gt; 0 &amp;&amp; tmp - 1 &lt;&#x3D; maxn &amp;&amp; path[tmp -1] &#x3D;&#x3D; tmp -1)\n        &#123;\n            q.push(tmp - 1);\n            path[tmp - 1] &#x3D; tmp;\n            if(tmp - 1 &#x3D;&#x3D; y) return;\n        &#125;\n\n    &#125;\n&#125;\n\nint main()\n&#123;\n    int x, y, cnt &#x3D; 0;\n    cin &gt;&gt; x &gt;&gt; y;\n\n    for(int i &#x3D; 0; i &lt;&#x3D; maxn - 1; i++)\n    &#123;\n        path[i] &#x3D; i;\n    &#125;\n    bfs(x, y);\n\n    path[x] &#x3D; x;\n    stack&lt;int&gt; result;\n    while(path[y] !&#x3D; y)\n    &#123;\n        cnt++;\n        result.push(y);\n        y &#x3D; path[y];\n    &#125;\n\n    cout &lt;&lt; cnt &lt;&lt; endl;\n\n    while(!result.empty())\n    &#123;\n        cout &lt;&lt; result.top();\n        result.pop();\n        if(!result.empty()) cout &lt;&lt; &quot; &quot;;\n    &#125;\n    &#x2F;&#x2F;cout &lt;&lt; endl;\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"教训-1\"><a href=\"#教训-1\" class=\"headerlink\" title=\"教训\"></a><strong>教训</strong></h3><p>结尾输出空行会导致第一个样例因为格式错误过不了。以后OJ出现这种异常，可以试试更改一下格式。</p>\n<h2 id=\"第三题：修轻轨\"><a href=\"#第三题：修轻轨\" class=\"headerlink\" title=\"第三题：修轻轨\"></a><strong>第三题：修轻轨</strong></h2><p>全屏浏览题目切换布局</p>\n<p>长春市有n个交通枢纽，计划在1号枢纽到n号枢纽之间修建一条轻轨。轻轨由多段隧道组成，候选隧道有m段。每段候选隧道只能由一个公司施工，施工天数对各家公司一致。有n家施工公司，每家公司同时最多只能修建一条候选隧道。所有公司可以同时开始施工。请评估：修建这条轻轨最少要多少天。</p>\n<h3 id=\"输入格式-2\"><a href=\"#输入格式-2\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>第1行，两个整数n和m，用空格分隔，分别表示交通枢纽的数量和候选隧道的数量，1 ≤ n ≤ 100000，1 ≤ m ≤ 200000。</p>\n<p>第2行到第m+1行，每行三个整数a、b、c，用空格分隔，表示枢纽a和枢纽b之间可以修建一条双向隧道，施工时间为c天，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000000。</p>\n<h3 id=\"输出格式-2\"><a href=\"#输出格式-2\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>输出一行，包含一个整数，表示最少施工天数。</p>\n<h3 id=\"输入样例-2\"><a href=\"#输入样例-2\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">6 6\n1 2 4\n2 3 4\n3 6 7\n1 4 2\n4 5 5\n5 6 6</code></pre>\n\n<h3 id=\"输出样例-2\"><a href=\"#输出样例-2\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">6</code></pre>\n\n<h3 id=\"题目解析-2\"><a href=\"#题目解析-2\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><p>一共有n个枢纽，即使由起点出发，遍历所有枢纽，到达终点，也只需要n-1条边，不需要考虑某一家公司需要完成第一条施工后再施工第二条。我们要求的就是从起点到终点的一条路径，使得该路径上的权值最大值最小，这时候就比较容易联想到最小生成树算法Kruskal，贪心思想，每一次都取最小的边加入并查集。经过推理，发现每次取边之后，判断一下起点和终点在同一集合内，哪怕选取的边最后不会使用，但是这样并不影响完成从起点到终点这一路径过程中的最大值。</p>\n<h4 id=\"方法一：Kruskal\"><a href=\"#方法一：Kruskal\" class=\"headerlink\" title=\"方法一：Kruskal\"></a><strong>方法一：Kruskal</strong></h4><h5 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h5><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nint pre[100001];\nint cur &#x3D; 0;\nint n, m, v1, v2, cost_tmp;\n\nint find(int x)\n&#123;\n    if(pre[x] &#x3D;&#x3D; x) return x;\n    return pre[x] &#x3D; find(pre[x]);\n&#125;\n\nvoid join(int x, int y)\n&#123;\n    int fx &#x3D; find(x), fy &#x3D; find(y);\n    if(fx !&#x3D; fy)\n        pre[fx] &#x3D; fy;\n&#125;\n\nstruct edge\n&#123;\n    int fr, to;\n    int cost;\n    edge(int _fr, int _to, int _cost):fr(_fr), to(_to), cost(_cost)&#123;&#125;;\n    bool operator &gt;(const edge &amp; b)const\n    &#123;\n        return cost &gt; b.cost;\n    &#125;\n&#125;;\n\npriority_queue&lt;edge,vector&lt;edge&gt;,greater&lt;edge&gt;&gt; list;\n\nint main()\n&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        pre[i] &#x3D; i;\n    &#125;\n\n    for(int i &#x3D; 0; i &lt;&#x3D; m - 1; i++)\n    &#123;\n        scanf(&quot;%d%d%d&quot;, &amp;v1, &amp;v2, &amp;cost_tmp);\n        edge *tmp &#x3D; new edge(v1, v2, cost_tmp);\n        list.push(*tmp);\n    &#125;\n\n    while(find(n) !&#x3D; find(1))\n    &#123;\n        if(list.empty()) break;\n        edge Edge &#x3D; list.top();\n        list.pop();\n        int vex1 &#x3D; Edge.fr;\n        int vex2 &#x3D; Edge.to;\n        int cost_cur &#x3D; Edge.cost;\n        if(find(vex1) !&#x3D; find(vex2))\n        &#123;\n            cur &#x3D; cost_cur;\n            join(vex1,vex2);\n        &#125;\n    &#125;\n\n    printf(&quot;%d&quot;, cur);\n    return 0;\n&#125;</code></pre>\n\n<h2 id=\"第四题：发红包\"><a href=\"#第四题：发红包\" class=\"headerlink\" title=\"第四题：发红包\"></a><strong>第四题：发红包</strong></h2><p>新年到了，公司要给员工发红包。员工们会比较获得的红包，有些员工会有钱数的要求，例如，c1的红包钱数要比c2的多。每个员工的红包钱数至少要发888元，这是一个幸运数字。</p>\n<p>公司想满足所有员工的要求，同时也要花钱最少，请你帮助计算。</p>\n<h3 id=\"输入格式-3\"><a href=\"#输入格式-3\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>第1行，两个整数n和m(n&lt;&#x3D;10000,m&lt;&#x3D;20000)，用空格分隔，分别代表员工数和要求数。</p>\n<p>接下来m行，每行两个整数c1和c2，用空格分隔，表示员工c1的红包钱数要比c2多，员工的编号1~n 。</p>\n<h3 id=\"输出格式-3\"><a href=\"#输出格式-3\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>一个整数，表示公司发的最少钱数。如果公司不能满足所有员工的需求，输出-1.</p>\n<h3 id=\"输入样例-3\"><a href=\"#输入样例-3\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">2 1\n1 2</code></pre>\n\n<h3 id=\"输出样例-3\"><a href=\"#输出样例-3\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">1777</code></pre>\n\n<h3 id=\"题目解析-3\"><a href=\"#题目解析-3\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><p>基础红包888元，钱数要求是整数，则可以视为边权均为1。</p>\n<p>假设有三个人：</p>\n<p>1:c1比c2多，c2比c3多。则：最少钱数：c1&#x3D;890, c2&#x3D;889, c3 &#x3D; 888;</p>\n<p>2:出现环：c1比c2多，c2比c3多，c3比c1多。这种情况的出现，会导致该公司不能满足所有员工的需求。</p>\n<p><img src=\"https://link.jscdn.cn/sharepoint/aHR0cHM6Ly9tYWlsc2psdWVkdWNuLW15LnNoYXJlcG9pbnQuY29tLzppOi9nL3BlcnNvbmFsL21lbmdzajU1MjFfbWFpbHNfamx1X2VkdV9jbi9FU3VuV3g1YlR2WkdrYmI4bHJmbFZQVUJ2c3lCMGRmbnJmdEhfWmJhWjBCQkxR.jpg\"></p>\n<p>本题目涉及有向，且先后关联，需要判环，应使用AOV拓扑排序。</p>\n<h4 id=\"方法一：AOV拓扑排序\"><a href=\"#方法一：AOV拓扑排序\" class=\"headerlink\" title=\"方法一：AOV拓扑排序\"></a><strong>方法一：AOV拓扑排序</strong></h4><h5 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h5><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nstruct vertex\n&#123;\n    int val;\n    vertex *next;\n    vertex(int v, vertex *n &#x3D; nullptr) : val(v), next(n)&#123;&#125;;\n&#125;;\n\nvertex *phead[10001] &#x3D; &#123;nullptr&#125;, *ptail[10001] &#x3D; &#123;nullptr&#125;;\nint du[10001];\nint plus_cnt[10001] &#x3D; &#123;0&#125;;\nqueue&lt;int&gt; q;\nint sum &#x3D; 0;\nint cnt &#x3D; 0;\n\nvoid add(int x, int y)\n&#123;\n    vertex *tmp &#x3D; ptail[x];\n    if (tmp &#x3D;&#x3D; nullptr)\n    &#123;\n        phead[x] &#x3D; new vertex(y);\n        ptail[x] &#x3D; phead[x];\n    &#125;\n    else\n    &#123;\n        ptail[x]-&gt;next &#x3D; new vertex(y);\n        ptail[x] &#x3D; ptail[x]-&gt;next;\n    &#125;\n    du[y]++;\n&#125;\n\nint n, m, v1, v2;\n\nint main()\n&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    sum &#x3D; n * 888;\n    for (int i &#x3D; 0; i &lt;&#x3D; m - 1; i++)\n    &#123;\n        cin &gt;&gt; v1 &gt;&gt; v2;\n        add(v2, v1);\n    &#125;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n    &#123;\n        if (du[i] &#x3D;&#x3D; 0)\n        &#123;\n            q.push(i);\n            cnt++;\n        &#125;\n    &#125;\n    while (!q.empty())\n    &#123;\n        int x;\n        x &#x3D; q.front();\n        q.pop();\n        vertex *tmp &#x3D; phead[x];\n        while (tmp !&#x3D; nullptr)\n        &#123;\n            du[tmp-&gt;val]--;\n            if (du[tmp-&gt;val] &#x3D;&#x3D; 0)\n            &#123;\n                q.push(tmp-&gt;val);\n                cnt++;\n            &#125;\n\n            if (plus_cnt[tmp-&gt;val] &lt; plus_cnt[x] + 1)\n            &#123;\n                plus_cnt[tmp-&gt;val] &#x3D; plus_cnt[x] + 1;\n            &#125;\n            tmp &#x3D; tmp-&gt;next;\n        &#125;\n    &#125;\n    int flag &#x3D; 1;\n    if (cnt !&#x3D; n)\n    &#123;\n        cout &lt;&lt; -1 &lt;&lt; endl;\n        flag &#x3D; 0;\n    &#125;\n\n    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)\n    &#123;\n        sum +&#x3D; plus_cnt[i];\n    &#125;\n\n    if (flag)\n        cout &lt;&lt; sum;\n\n    return 0;\n&#125;</code></pre>\n","text":"第一题： 图的深度优先搜索I无向图 G 有 n 个顶点和 m 条边。求图G的深度优先搜索树(森林)以及每个顶点的发现时间和完成时间。每个连通分量从编号最小的结点开始搜索，邻接顶点选择顺序遵循边的输入顺序。 在搜索过程中，第一次遇到一个结点，称该结点被发现；一个结点的所有邻接结点都...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":7,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":15,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":7,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E9%A2%98%EF%BC%9A-%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2I\"><span class=\"toc-text\">第一题： 图的深度优先搜索I</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">方法一：深度优先遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#DFS\"><span class=\"toc-text\">DFS</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">完整代码</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%99%E8%AE%AD\"><span class=\"toc-text\">教训</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%9A%E6%95%B0%E5%AD%97%E5%8F%98%E6%8D%A2\"><span class=\"toc-text\">第二题：数字变换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-1\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-1\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-1\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">方法一：广度优先遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#BFS\"><span class=\"toc-text\">BFS</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-1\"><span class=\"toc-text\">完整代码</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%99%E8%AE%AD-1\"><span class=\"toc-text\">教训</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E9%A2%98%EF%BC%9A%E4%BF%AE%E8%BD%BB%E8%BD%A8\"><span class=\"toc-text\">第三题：修轻轨</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-2\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-2\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-2\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AKruskal\"><span class=\"toc-text\">方法一：Kruskal</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1\"><span class=\"toc-text\">代码实现</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%9B%9B%E9%A2%98%EF%BC%9A%E5%8F%91%E7%BA%A2%E5%8C%85\"><span class=\"toc-text\">第四题：发红包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-3\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-3\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-3\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-3\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-3\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AAOV%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">方法一：AOV拓扑排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2\"><span class=\"toc-text\">代码实现</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"数据结构第五次上机实验","uid":"11dfa7e5794f08feee18d1b7215f1a65","slug":"数据结构第五次上机实验","date":"2022-09-06T04:02:18.000Z","updated":"2023-02-28T17:40:56.663Z","comments":true,"path":"api/articles/数据结构第五次上机实验.json","keywords":null,"cover":null,"text":"第一题：重复计数在一个有限的正整数序列中，有些数会多次重复出现。请你统计每个数的出现次数，然后按数字在序列中第一次出现的位置顺序输出数及其次数。 输入格式第1行，1个整数N，表示整数的个数，(1≤N≤50000)。 第2行，N个正整数，每个整数x 都满足 1 ≤ x ≤20000...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":7,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":15,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":7,"path":"api/tags/数据结构.json"}],"author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"数据结构第三次上机实验","uid":"9273a260bb46152a3f86150e633d4306","slug":"数据结构第三次上机实验","date":"2022-09-06T03:59:53.000Z","updated":"2023-02-28T17:40:58.041Z","comments":true,"path":"api/articles/数据结构第三次上机实验.json","keywords":null,"cover":null,"text":"第一题：连通分量无向图 G 有 n 个顶点和 m 条边。求 G 的连通分量的数目。 输入格式：第1行，2个整数n和m，用空格分隔，分别表示顶点数和边数， 1≤n≤50000， 1≤m≤100000. 第2到m+1行，每行两个整数u和v，用空格分隔，表示顶点u到顶点v有一条边，u和...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":7,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":15,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":7,"path":"api/tags/数据结构.json"}],"author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}