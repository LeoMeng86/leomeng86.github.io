{"title":"数据结构第五次上机实验","uid":"11dfa7e5794f08feee18d1b7215f1a65","slug":"数据结构第五次上机实验","date":"2022-09-06T04:02:18.000Z","updated":"2023-02-28T17:40:56.663Z","comments":true,"path":"api/articles/数据结构第五次上机实验.json","keywords":null,"cover":null,"content":"<h2 id=\"第一题：重复计数\"><a href=\"#第一题：重复计数\" class=\"headerlink\" title=\"第一题：重复计数\"></a><strong>第一题：重复计数</strong></h2><p>在一个有限的正整数序列中，有些数会多次重复出现。请你统计每个数的出现次数，然后按数字在序列中第一次出现的位置顺序输出数及其次数。</p>\n<h3 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>第1行，1个整数N，表示整数的个数，(1≤N≤50000)。</p>\n<p>第2行，N个正整数，每个整数x 都满足 1 ≤ x ≤2000000000。</p>\n<h3 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>若干行，每行两个用一个空格隔开的数，第一个是数列中出现的数，第二个是该数在序列中出现的次数。</p>\n<h3 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">12\n8 2 8 2 2 11 1 1 8 1 13 13</code></pre>\n\n<h3 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">8 3\n2 3\n11 1\n1 3\n13 2</code></pre>\n\n<h3 id=\"题目解析\"><a href=\"#题目解析\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><h4 id=\"方法一：STL\"><a href=\"#方法一：STL\" class=\"headerlink\" title=\"方法一：STL\"></a><strong>方法一：STL</strong></h4><p>STL大法好，map的find时间复杂度是log级别，找到了会返回目标的迭代器，找不到会返回end()，然后用一个queue来存顺序，STL我的神！！！</p>\n<h5 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h5><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nint main()\n&#123;\n    int n, tmp;\n    scanf(&quot;%d&quot;, &amp;n);\n    map&lt;int, int&gt; m;\n    queue&lt;int&gt; Q;\n    while (n--)\n    &#123;\n        scanf(&quot;%d&quot;, &amp;tmp);\n        auto it &#x3D; m.find(tmp);\n        if (it &#x3D;&#x3D; m.end())\n        &#123;\n            Q.push(tmp);\n            m.insert(pair&lt;int, int&gt;(tmp, 1));\n        &#125;\n        else\n            it-&gt;second++;\n    &#125;\n    while (!Q.empty())\n    &#123;\n        auto it &#x3D; m.find(Q.front());\n        Q.pop();\n        cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second;\n        m.erase(it);\n        if (Q.size() &gt;&#x3D; 1)\n            cout &lt;&lt; &quot;\\\\n&quot;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h2 id=\"第二题：字符串周期\"><a href=\"#第二题：字符串周期\" class=\"headerlink\" title=\"第二题：字符串周期\"></a><strong>第二题：字符串周期</strong></h2><p>一个字符串可以看成由某个长度为k的前缀重复若干次得到，称k为该字符串的周期。例如：”abababab”以2、4、8为周期。请计算一个字符串的最小周期。</p>\n<h3 id=\"输入格式-1\"><a href=\"#输入格式-1\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>输入包含多行。每行包含一个字符串s，s至少1个字符，最多1000000个字符。最后一行是一个点，表示输入结束，不必求解。输入较大，建议使用scanf。</p>\n<h3 id=\"输出格式-1\"><a href=\"#输出格式-1\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>多行，每行一个整数，对应每一行输入s的最小周期。</p>\n<h3 id=\"输入样例-1\"><a href=\"#输入样例-1\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">abcd\naaaa\nababab\n.</code></pre>\n\n<h3 id=\"输出样例-1\"><a href=\"#输出样例-1\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">4\n1\n2</code></pre>\n\n<h3 id=\"题目解析-1\"><a href=\"#题目解析-1\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><h4 id=\"方法一：朴素匹配\"><a href=\"#方法一：朴素匹配\" class=\"headerlink\" title=\"方法一：朴素匹配\"></a><strong>方法一：朴素匹配</strong></h4><p>感觉应该过不了，没有写，刚讲了kmp，估计用kmp才是正解（doge）；</p>\n<h4 id=\"方法二：KMP\"><a href=\"#方法二：KMP\" class=\"headerlink\" title=\"方法二：KMP\"></a><strong>方法二：KMP</strong></h4><p>本题目我选择了next数组的方法。即求前后缀的最大匹配值。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int num &#x3D; 1000001;\nvoid Next(char *s, int next[])\n&#123;\n    next[0] &#x3D; -1;\n    int k &#x3D; -1;\n    int j &#x3D; 0;\n    int len &#x3D; strlen(s);\n\n    while (j &lt; len)\n    &#123;\n        if (k &#x3D;&#x3D; -1 || s[j] &#x3D;&#x3D; s[k])\n        &#123;\n            ++k;\n            ++j;\n            next[j] &#x3D; k;\n        &#125;\n        else\n        &#123;\n            k &#x3D; next[k];\n        &#125;\n    &#125;\n&#125;\n\nint MinCycle(char *s)\n&#123;\n\n    int next[num];\n    Next(s, next);\n\n    int len &#x3D; strlen(s);\n    int mclen &#x3D; len - next[len];\n    return mclen;\n&#125;\n\nint main()\n&#123;\n    char s[1000001];\n    while (1)\n    &#123;\n        scanf(&quot;%s&quot;, s);\n        if (strcmp(s, &quot;.&quot;) &#x3D;&#x3D; 0)\n            break;\n        cout &lt;&lt; MinCycle(s) &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h2 id=\"第三题：交换次数\"><a href=\"#第三题：交换次数\" class=\"headerlink\" title=\"第三题：交换次数\"></a><strong>第三题：交换次数</strong></h2><p>序列A中有N个整数。</p>\n<p>求对A进行冒泡排序发生的元素交换次数。</p>\n<h3 id=\"输入格式-2\"><a href=\"#输入格式-2\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>第一行输入整数N(2&lt;&#x3D;N&lt;&#x3D;10^6).接下来一行N个正整数数A[i] (1≤i≤N ，A[i]&lt;&#x3D;10^6)。</p>\n<h3 id=\"输出格式-2\"><a href=\"#输出格式-2\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>一行，有一个整数，表示元素交换的次数。</p>\n<h3 id=\"输入样例-2\"><a href=\"#输入样例-2\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">4\n2 4 3 1</code></pre>\n\n<h3 id=\"输出样例-2\"><a href=\"#输出样例-2\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">4</code></pre>\n\n<h3 id=\"题目解析-2\"><a href=\"#题目解析-2\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><h4 id=\"方法一：树状数组\"><a href=\"#方法一：树状数组\" class=\"headerlink\" title=\"方法一：树状数组\"></a><strong>方法一：树状数组</strong></h4><p>冒泡排序的交换次数，取决于逆序数的数量，本题目使用树状数组计算逆序数，树状数组和线段树类似，可以实现单点更新单点查询，单点更新区间查询，区间更新单点查询，区间更新区间查询。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nconst int maxn &#x3D; 1e6 +10;\n\nint n;\nint bit[maxn];\nint a[maxn];\n\nint sum(int i)\n&#123;\n    int s &#x3D; 0;\n    while(i&gt;0)&#123;\n        s +&#x3D; bit[i];\n        i -&#x3D; i &amp; -i;\n    &#125;\n    return s;\n&#125;\n\nvoid add(int i)\n&#123;\n    while(i&lt;&#x3D;maxn)&#123;\n        bit[i] +&#x3D; 1;\n        i +&#x3D; i &amp; -i;\n    &#125;\n&#125;\n\nvoid solve()\n&#123;\n    long long ans &#x3D; 0;\n    for(int j &#x3D; 0;j&lt;n;j++)&#123;\n        ans +&#x3D; j - sum(a[j]);\n        add(a[j]);\n    &#125;\n    printf(&quot;%lld\\\\n&quot;,ans);\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d&quot;,&amp;n);\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        scanf(&quot;%d&quot;,&amp;a[i]);\n    &#125;\n    solve();\n    return 0;\n&#125;</code></pre>\n\n<h2 id=\"第四题：维护序列\"><a href=\"#第四题：维护序列\" class=\"headerlink\" title=\"第四题：维护序列\"></a><strong>第四题：维护序列</strong></h2><p>一个序列初始为空。给出N(N&lt;&#x3D;1000000)个操作维护序列。</p>\n<h3 id=\"输入格式-3\"><a href=\"#输入格式-3\" class=\"headerlink\" title=\"输入格式\"></a><strong>输入格式</strong></h3><p>第1行 整数N；然后有N行，每行两个数，ch和kch&#x3D;1表示插入一个值为k的数ch&#x3D;2表示查询第k小的数（k合法）ch&#x3D;3表示删除值为k的数(k一定存在)</p>\n<h3 id=\"输出格式-3\"><a href=\"#输出格式-3\" class=\"headerlink\" title=\"输出格式\"></a><strong>输出格式</strong></h3><p>输出查询操作的结果值。每个一行。</p>\n<h3 id=\"输入样例-3\"><a href=\"#输入样例-3\" class=\"headerlink\" title=\"输入样例\"></a><strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">5\n1 2\n1 3\n2 1\n3 2\n2 1</code></pre>\n\n<h3 id=\"输出样例-3\"><a href=\"#输出样例-3\" class=\"headerlink\" title=\"输出样例\"></a><strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">2\n3</code></pre>\n\n<h3 id=\"题目解析-3\"><a href=\"#题目解析-3\" class=\"headerlink\" title=\"题目解析\"></a><strong>题目解析</strong></h3><p>能满足插入值为k的数，查询第k小的数，删除值为k的数的数据结构，限制1000ms，应该选择高度平衡树。据说还卡splay，没有写过类似的板子，看到这个题目，简直绝望，用暴力法骗了20分，只能下课请教大佬。感谢mxgg和zygg提供的treap的解法和帮我一起debug，我哭死。</p>\n<p>treap是树堆，比较容易实现，比较基础，且常数不大。有BST的性质，也有Heap的性质，可以维护排名，又能保证深度在logn级别。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int maxn &#x3D; 1e7 + 7;\nconst int mod &#x3D; 1e7 + 7;\n\nstruct node\n&#123;\n\tint key, rd, pl, pr, size;\n&#125; tree[maxn];\n\nint sz, root;\n\ninline void maintain(int x)\n&#123;\n\ttree[x].size &#x3D; tree[tree[x].pl].size + tree[tree[x].pr].size + 1;\n&#125;\n\ninline void R_rorate(int &amp;p)\n&#123;\n\tint ii &#x3D; tree[p].pl;\n\ttree[p].pl &#x3D; tree[ii].pr;\n\ttree[ii].pr &#x3D; p;\n\ttree[ii].size &#x3D; tree[p].size;\n\tmaintain(p);\n\tp &#x3D; ii;\n&#125;\n\ninline void L_rorate(int &amp;p)\n&#123;\n\tint ii &#x3D; tree[p].pr;\n\ttree[p].pr &#x3D; tree[ii].pl;\n\ttree[ii].pl &#x3D; p;\n\ttree[ii].size &#x3D; tree[p].size;\n\tmaintain(p);\n\tp &#x3D; ii;\n&#125;\n\ninline void insert(int &amp;p, int x)\n&#123;\n\tif (p &#x3D;&#x3D; 0)\n\t&#123;\n\t\tp &#x3D; ++sz;\n\t\ttree[p].size &#x3D; 1;\n\t\ttree[p].key &#x3D; x;\n\t\ttree[p].rd &#x3D; rand() * rand() % mod;\n\t\treturn;\n\t&#125;\n\ttree[p].size++;\n\tif (x &gt;&#x3D; tree[p].key)\n\t&#123;\n\t\tinsert(tree[p].pr, x);\n\t&#125;\n\telse\n\t&#123;\n\t\tinsert(tree[p].pl, x);\n\t&#125;\n\tif (tree[p].pl !&#x3D; 0 &amp;&amp; tree[p].rd &gt; tree[tree[p].pl].rd)\n\t&#123;\n\t\tR_rorate(p);\n\t&#125;\n\tif (tree[p].pr !&#x3D; 0 &amp;&amp; tree[p].rd &gt; tree[tree[p].pr].rd)\n\t&#123;\n\t\tL_rorate(p);\n\t&#125;\n\tmaintain(p);\n&#125;\n\ninline void remove(int &amp;p, int x)\n&#123;\n\ttree[p].size--;\n\tif(tree[p].key &#x3D;&#x3D; x)\n\t&#123;\n\t\tif (tree[p].pl &#x3D;&#x3D; 0 &amp;&amp; tree[p].pr &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tp &#x3D; 0;\n\t\t\treturn;\n\t\t&#125;\n\t\tif (tree[p].pl &#x3D;&#x3D; 0 || tree[p].pr &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tp &#x3D; tree[p].pl + tree[p].pr;\n\t\t\treturn;\n\t\t&#125;\n\t\tif (tree[tree[p].pl].rd &lt; tree[tree[p].pr].rd)\n\t\t&#123;\n\t\t\tR_rorate(p);\n\t\t\tremove(tree[p].pr, x);\n\t\t\treturn;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tL_rorate(p);\n\t\t\tremove(tree[p].pl, x);\n\t\t\treturn;\n\t\t&#125;\n\t&#125;\n\n\tif (tree[p].key &lt;&#x3D; x)\n\t&#123;\n\t\tremove(tree[p].pr, x);\n\t&#125;\n\telse\n\t&#123;\n\t\tremove(tree[p].pl, x);\n\t&#125;\n\tmaintain(p);\n&#125;\n\ninline int kth(int p, int x)\n&#123;\n\tif (x &#x3D;&#x3D; tree[tree[p].pl].size + 1)\n\t&#123;\n\t\treturn tree[p].key;\n\t&#125;\n\tif (x &gt; tree[tree[p].pl].size + 1)\n\t&#123;\n\t\treturn kth(tree[p].pr, x - tree[tree[p].pl].size - 1);\n\t&#125;\n\treturn kth(tree[p].pl, x);\n&#125;\n\nint main()\n&#123;\n\tios::sync_with_stdio(false); cin.tie(nullptr);\n\tsrand(mod);\n\tint n;\n\tscanf(&quot;%d&quot;, &amp;n);\n\tint ch, ch1;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++)\n\t&#123;\n\t\tscanf(&quot;%d%d&quot;, &amp;ch, &amp;ch1);\n\t\tswitch (ch)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tinsert(root, ch1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(&quot;%d\\\\n&quot;, kth(root, ch1));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tremove(root, ch1);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n","text":"第一题：重复计数在一个有限的正整数序列中，有些数会多次重复出现。请你统计每个数的出现次数，然后按数字在序列中第一次出现的位置顺序输出数及其次数。 输入格式第1行，1个整数N，表示整数的个数，(1≤N≤50000)。 第2行，N个正整数，每个整数x 都满足 1 ≤ x ≤20000...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":7,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":15,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":7,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E9%A2%98%EF%BC%9A%E9%87%8D%E5%A4%8D%E8%AE%A1%E6%95%B0\"><span class=\"toc-text\">第一题：重复计数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ASTL\"><span class=\"toc-text\">方法一：STL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">第二题：字符串周期</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-1\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-1\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-1\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9C%B4%E7%B4%A0%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">方法一：朴素匹配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9AKMP\"><span class=\"toc-text\">方法二：KMP</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E9%A2%98%EF%BC%9A%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">第三题：交换次数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-2\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-2\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-2\"><span class=\"toc-text\">题目解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">方法一：树状数组</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%9B%9B%E9%A2%98%EF%BC%9A%E7%BB%B4%E6%8A%A4%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">第四题：维护序列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-3\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-3\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-3\"><span class=\"toc-text\">输入样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-3\"><span class=\"toc-text\">输出样例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-3\"><span class=\"toc-text\">题目解析</span></a></li></ol></li></ol>","author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"数据结构第六次上机实验","uid":"92dcc63de0a91e6ef330681692883b4c","slug":"数据结构第六次上机实验","date":"2022-09-06T04:02:32.000Z","updated":"2023-02-28T17:40:59.563Z","comments":true,"path":"api/articles/数据结构第六次上机实验.json","keywords":null,"cover":null,"text":"第一题：稀疏矩阵之差矩阵A和B都是稀疏矩阵。请计算矩阵的差A-B.如果A、B不能计算差值，输出”Illegal!” 输入格式矩阵的输入采用三元组表示，先A后B。对每个矩阵： 第1行，3个整数N、M、t，用空格分隔，分别表示矩阵的行数、列数和非0数据项数，10≤N、M≤50000，...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":7,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":15,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":7,"path":"api/tags/数据结构.json"}],"author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"数据结构第四次上机实验","uid":"7d8e8db1d60b240c8f6df95f6b0082a1","slug":"数据结构第四次上机实验","date":"2022-09-06T04:00:18.000Z","updated":"2023-02-28T17:40:58.024Z","comments":true,"path":"api/articles/数据结构第四次上机实验.json","keywords":null,"cover":[],"text":"第一题： 图的深度优先搜索I无向图 G 有 n 个顶点和 m 条边。求图G的深度优先搜索树(森林)以及每个顶点的发现时间和完成时间。每个连通分量从编号最小的结点开始搜索，邻接顶点选择顺序遵循边的输入顺序。 在搜索过程中，第一次遇到一个结点，称该结点被发现；一个结点的所有邻接结点都...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":7,"path":"api/categories/数据结构.json"}],"tags":[{"name":"编程","slug":"编程","count":15,"path":"api/tags/编程.json"},{"name":"数据结构","slug":"数据结构","count":7,"path":"api/tags/数据结构.json"}],"author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}