{"title":"CPP第三次上机实验","uid":"60136b05a7965396e962d3122dd90a33","slug":"CPP第三次上机实验","date":"2022-09-08T01:55:21.000Z","updated":"2023-02-28T17:40:56.624Z","comments":true,"path":"api/articles/CPP第三次上机实验.json","keywords":null,"cover":null,"content":"<p>地图导航模拟算法。在一个无向图中任意给定两点实现最短路径计算。要求采用Dijkstra（深度或广度或Floyd或Bellman-Ford）算法，以及堆排序算法或其它排序算法，利用递归，vector支持邻接表方式，对于路径和选择路径进行界面显示（可仅仅显示而不交互）。主要目的：vector的理解，可视化编程的理解。</p>\n<h2 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a><strong>题目要求</strong></h2><h3 id=\"后端要求\"><a href=\"#后端要求\" class=\"headerlink\" title=\"后端要求\"></a><strong>后端要求</strong></h3><p>完成任意指定两点的最短路径计算，采用最短路算法，使用堆优化或其它排序算法，优化最短路算法，使用vector存图的邻接表。</p>\n<h3 id=\"前端要求\"><a href=\"#前端要求\" class=\"headerlink\" title=\"前端要求\"></a><strong>前端要求</strong></h3><p>对于图的路径以及选择路径进行界面展示，可以仅仅显示但是不交互。</p>\n<h2 id=\"主要流程及解决思路\"><a href=\"#主要流程及解决思路\" class=\"headerlink\" title=\"主要流程及解决思路\"></a><strong>主要流程及解决思路</strong></h2><h3 id=\"主要流程\"><a href=\"#主要流程\" class=\"headerlink\" title=\"主要流程\"></a><strong>主要流程</strong></h3><p>1，写一个小根堆。</p>\n<p>2，建立Vertex类，储存图的邻接表。</p>\n<p>3，建立一个堆存 pair &amp;lt int ,int &amp;gt (cost, val) 存一个边集小根堆。</p>\n<p>4，利用堆写Dijkstra。</p>\n<p>5，建立EasyX界面，通过“建立地点”和“建立路线”或“文件读入”方式完成图的绘制。</p>\n<p>6，建立地点，在界面中以像素点进行标点，每次建点会向vector中进行一次push_back</p>\n<p>7，建立路线，输出起点和终点和边权，会完成邻接表的双向add，同时储存一个用于显示的边集。</p>\n<p>8，运行Dijkstra算法，计算路程，并把路线标红。</p>\n<h3 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a><strong>解决思路</strong></h3><p>要求使用简单的前端编程，对于C++，我已知的有EasyX和Qt。我在C语言课程设计中曾经使用过EasyX进行界面的设计，本次将继续使用EasyX完成相应的前端设计。要求使用求最短路的算法，因为题目要求，仅需要求给定两点之间的最短路，使用Floyd等最短路算法，求各源最短路有歼星炮打蚊子的感觉，本次选择了求单元最短路的Dijkstra算法，堆优化后可以达到O（mlogn）的级别，相比于Floyd的O(n^3）要优不少。</p>\n<h2 id=\"程序的难点及遇到的问题\"><a href=\"#程序的难点及遇到的问题\" class=\"headerlink\" title=\"程序的难点及遇到的问题\"></a><strong>程序的难点及遇到的问题</strong></h2><p>使用EasyX时，为了可以将控制按键与画面分开，进行了setorigin操作，但是鼠标的检测，不随着setorigin进行改变，导致出现无法鼠标操控的情况，进行了较长时间的debug。</p>\n<h3 id=\"程序的优缺点\"><a href=\"#程序的优缺点\" class=\"headerlink\" title=\"程序的优缺点\"></a><strong>程序的优缺点</strong></h3><p>使用了堆优化的Dijkstra算法，效率较优。使用鼠标控制，实现了简单的交互功能，边权的设置不仅仅通过两点之间的距离，提高了自由度，有利于进一步考察交通等各种因素。</p>\n<h2 id=\"我的收获\"><a href=\"#我的收获\" class=\"headerlink\" title=\"我的收获\"></a><strong>我的收获</strong></h2><p>进一步掌握了有关EasyX的相关操作，对可视化编程有了进一步的理解。通过图形化的展示，对Dijkstra算法有了更深的理解。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h2><p><strong><a href=\"https://github.com/LeoMeng86/JLU_cpp_experiment.git\">https://github.com/LeoMeng86/JLU_cpp_experiment.git</a></strong></p>\n","text":"地图导航模拟算法。在一个无向图中任意给定两点实现最短路径计算。要求采用Dijkstra（深度或广度或Floyd或Bellman-Ford）算法，以及堆排序算法或其它排序算法，利用递归，vector支持邻接表方式，对于路径和选择路径进行界面显示（可仅仅显示而不交互）。主要目的：ve...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"C&C++","slug":"C-C","count":8,"path":"api/categories/C-C.json"}],"tags":[{"name":"CPP","slug":"CPP","count":8,"path":"api/tags/CPP.json"},{"name":"编程","slug":"编程","count":14,"path":"api/tags/编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">题目要求</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8E%E7%AB%AF%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">后端要求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">前端要求</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">主要流程及解决思路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">主要流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">解决思路</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%9A%BE%E7%82%B9%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">程序的难点及遇到的问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">程序的优缺点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%91%E7%9A%84%E6%94%B6%E8%8E%B7\"><span class=\"toc-text\">我的收获</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a></li></ol>","author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CPP第四次上机实验","uid":"b294dc564007bd3ddd0057552526566b","slug":"CPP第四次上机实验","date":"2022-09-08T01:55:40.000Z","updated":"2023-02-28T17:40:55.247Z","comments":true,"path":"api/articles/CPP第四次上机实验.json","keywords":null,"cover":null,"text":"题目理解我对题目的理解是讲PPT中类的双向关联程序改为单向关联程序，并在main函数中调用。 程序难点及解决思路本次的程序难点在于如何将双向关联改为单向关联，PPT中给出的方案是在Male类中设立一个静态的数组储存每一个新建的Male类，Male类中还储存了Female类，Fem...","link":"","photos":[],"count_time":{"symbolsCount":439,"symbolsTime":"1 mins."},"categories":[{"name":"C&C++","slug":"C-C","count":8,"path":"api/categories/C-C.json"}],"tags":[{"name":"CPP","slug":"CPP","count":8,"path":"api/tags/CPP.json"},{"name":"编程","slug":"编程","count":14,"path":"api/tags/编程.json"}],"author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CPP第二次上机实验","uid":"c943e7e0ca1458fff17cfd3d10a5007a","slug":"CPP第二次上机实验","date":"2022-09-08T01:55:00.000Z","updated":"2023-02-28T17:40:56.645Z","comments":true,"path":"api/articles/CPP第二次上机实验.json","keywords":null,"cover":null,"text":"题目要求要求使用类封装的知识，和重载函数，构造函数，析构函数等知识，完成对string类型的封装。构造函数实现直接定义一个空string，用已经定义的string复制一个新的string，定义一个n位’m’字符的string，或者截取已有string的一部分。重载方面实现了str...","link":"","photos":[],"count_time":{"symbolsCount":956,"symbolsTime":"1 mins."},"categories":[{"name":"C&C++","slug":"C-C","count":8,"path":"api/categories/C-C.json"}],"tags":[{"name":"CPP","slug":"CPP","count":8,"path":"api/tags/CPP.json"},{"name":"编程","slug":"编程","count":14,"path":"api/tags/编程.json"}],"author":{"name":"Leo Meng","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/LeoMeng86","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}