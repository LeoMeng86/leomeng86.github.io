[{"id":"c440061768efe9bf5183c05fdcd8c615","title":"CPP课程设计","content":"模拟即时通信系统实现设计任务分析使用C++设计一个模拟即时通讯系统，使用socket套接字通信技术，完成用户对用户的交流和群内交流，使用多态继承等面向对象技术，QQ，微信，微博系统的建立，实现群管理等功能。\n设计方案本次实验使用Qt进行开发，完成可视化编程，网络通信编程,数据库编程和多线程编程任务，使用多态及继承等面向对象设计，基本实现前后端分离，客户端服务段分离。\n客户端后端QQ端支持群和好友聊天，微信端仅支持好友交流，微博端为全体用户分享生活的平台，无好友机制。\n平台类的建立：建立platform_msj基类，QQ_platform_msj, WeChat_platform_msj,  WeiBo_platform_msj等三个派生类继承基类。\n用户类建立：建立users_msj类，设计QQ_users_msj类继承users_msj类。\n群类建立：建立Group_msj类。\n前端设计6个页面：frontpage_msj, loginpage_msj, register_msj, friend_msj, tepclient_msj，groupmanage_msj。\nFrontpage_msj实现了QQ，微信，微博的选择，通过不同的QPushbutton的槽函数，使用platform_msj基类指针，new子类对象，并读取数据库中的相应用户信息，保存到QVector中。\n\nLoginpage_msj实现了登录功能，以及注册页面的跳转，通过对用户id和password的判断，实现对应用户登录，并从该用户对应的文件中读入相应好友以及群组信息。\n\n\nFriendpage_msj实现了添加好友新建群以及群的功能，且使用了网络编程，加群和好友的方案均采用单方同意即可，同时在groupmanage_msj功能中，拉入好友以及删除群友，采用直接拉入和踢出的策略。\n\n\n\nTcpclient_msj使用socket进行通讯，向服务端发送消息，同时接收服务端发来的消息。\n\n服务端后端继承了QTcpSocket类建立了tcpclientsocket_msj类，继承了QTcpServer类建立了Server_msj类。实现了收到消息通过QString类的section成员函数实现了##字符串之间的分割，通过其中附带的发送者信息和接收者信息查询已经完成绑定的socket，如果在线即转发消息，若不在线则转发其不在线消息。群和微博直接转发消息，不进行判断。\n前端仅设计一个页面，通过QListWidget记录登录日志，通过QtextEdit记录收发信息。可使用广播功能向所有打开聊天框的用户转发消息。\n\n详细设计用户信息保存通过数据库读写，在选定平台后，读入信息，使用sql语言·，使用atEnd()成员函数判断是否读到文件尾部，以users_msj类存到platfrom_msj的QVector成员中。在注册时候，使用append模式，QTextStream流输入并在QVector中加入新信息。\n好友和群的添加分别在相应QVector中插入信息，同时向相应的文件中进行读写，再对界面进行更新。\n微信QQ微博多平台实现通过设计platform_msj基类，设置了init()等接口，再使用QQ_platform_msj，WeChat_platform_msj，WeiBo_platform_msj等派生类对父类进行继承和重写，实现了多平台。其中QQ支持好友和群功能，微信支持好友功能，微博所有用户均在同一平台进行聊天。\n不同平台用户存不同信息设计users_msj类，使用QQ_users_msj继承父类，并派生，实现了QQ额外的存群列表的功能。\n通信功能的实现使用socket套接字通信的方式，通过继承Qt自带的QTcpServer和QTcpSocket类，使用connect信号和readyread信号，连接服务器和读取服务器发来的信息，通过重写QTcpServer的incomingConnection成员函数，实现保存客户端套接字和姓名。\n消息的传递进行消息传递时候，为实现点对点或点对群通信，使用QString的section成员函数，通过##分割各部分信息，在服务端进行解构，向指定客户端发送消息。\n历史记录保存使用MySQL，每条信息按发送者，接收者，时间，消息进行存储，每次初始化时，从MySQL中将历史消息重新读入。\n总结与体会优缺点使用了面向对象思想，使用可视化编程，网络通信编程，实现了点对点通信和点对群通信，使用数据库。\n调试中遇到的问题Qt使用信号和槽的方式传递信息，在connect信号和槽的过程中出现了许多错误，使用ui界面的相关槽的配合也带来了一定的麻烦。还有qt的父对象机制，在父对象析构之后会析构相应的子对象，导致部分页面无法显示。解决方法，在需要槽或信号的位置使用注释，理清思路，对相应父对象析构后，建立指向空对象的页面，防止页面被析构，在使用结束后进行析构，解除空间占用。\n总结本次课程设计使用了Qt进行可视化开发，Qt的库中的类均为继承关系，通过对Qt中类的使用，和自己设计不同类的过程中，更为了解了面向对象的思想。\n","slug":"CPP课程设计","date":"2022-10-29T08:38:54.000Z","categories_index":"C&C++","tags_index":"CPP,编程","author_index":"Leo Meng"},{"id":"f5549e64dae0916ed3c2d5ca434b3e7c","title":"CPP第七次上机实验","content":"组合模式的应用，每个公司都有总部，多个分公司，多个办事处等，为上下级同构的实体关系。每个公司有人力部，财务部，销售部等职能部门，不再有下级部门，分公司下面继续有子公司。总部需要快速了解总公司的组织结构+实体职责展示。两个多态函数，输出文字即可。\n题目要求1）应用组合模式的模式设计方式。\n2）建立上下级同构的实体关系。\n3）总部需要快速了解总公司的组织结构和实体职责展示，使用多态函数，输出文字。\n组合模式设计图设计一个University类，包含attach，detach，display和lineofduty函数。Compus类和各Department类通过继承University类，实现Component和Leaf部分的设计。其中可以通过attach函数绑定下属部门，通过detach函数删除下属部门。通过display和lineofduty两个多态函数实现输出结构以及各部门只能，各Department类直接输出自己的内容，其它类在完成自身输出后继续输出自己下属部门。\n\n本题测试使用的结构学校下属有学院和教务部等部门，教务部的等部门下属不再设下属部门，学院下属继续设置下属部门。\n\n程序难点1）多态函数的使用。\n使用虚函数，以及继承，多态等知识完成多态函数的建立。\n2）下级部门的储存方式。\n使用STL中的list容器，储存实例中学校或学院的子部门。\n不使用多态如何实现，以及困难可以每一个类都单独定义函数，麻烦在于难以访问其它封装类的内容，输出过程会相对困难。\n我的收获对多态的运用有了更深的理解。初步了解组合模式的概念。\n代码实现https://github.com/LeoMeng86/JLU_cpp_experiment.git\n","slug":"CPP第七次上机实验","date":"2022-09-08T01:56:17.000Z","categories_index":"C&C++","tags_index":"CPP,编程","author_index":"Leo Meng"},{"id":"1510154d893520be8184890df2533c82","title":"CPP第六次上机实验","content":"模拟一个小型数据库系统（DBMS）的实现，最小化的实现数据库和数据表的管理，实现数据库和数据表和数据的增加，查询，修改和删除（可以考虑多态），数据存储使用oi类，储存文件可以用文本格式也可以用XML或者其他专门格式，操作指令发布可以使用界面，可以使用自定义管理器支持的简单字符命令或者类似SQL语言。\n数据库，数据表，数据的概念；SQL语言的概念数据库是一个按数据结构来存储和管理数据的计算机软件系统。\n数据表是数据库的重要组成部分，每一个数据库都是由若干个数据表组成的。\nSQL结构化查询语言是关系数据库中最普遍使用的语言。主要包括查询、数据操纵、数据定义、数据控制功能，是一种通用的、功能强大的关系数据库的标准语言。\n题目要求1）通过文件模拟数据库，实现增删改查\n2）支持简单的字符命令或SQL语言\n实现难点1）需要使用文件夹来模拟数据库，使用文件来模拟数据表，将每条数据放在一行显示，每次操作都需要整行进行。\n2）文件的IO类的定位有难度，几乎每次都需要重新定位到文件头或者文件尾。\n解决思路1）将数据按行存储，在查询等过程中以整行的形式展示，分级别打开，打开数据表之前要先判断是否已经打开数据库，每次打开数据表，只需要单独输出数据表名称即可。\n2）每次选取数据表后，使用vector将整个文件，按行读入，方便删除等操作。\n数据库在软件中的地位数据库把软件运行所需要的数据，存在数据库中，方便软件运行过程中的读取以及使用。\n我的收获进一步了解了数据库的相关概念，对CPP的IO类有了进一步的理解和使用，提高了编程能力。\n代码实现https://github.com/LeoMeng86/JLU_cpp_experiment.git\n","slug":"CPP第六次上机实验","date":"2022-09-08T01:56:05.000Z","categories_index":"C&C++","tags_index":"CPP,编程","author_index":"Leo Meng"},{"id":"574b7681991a8086c7052a1109c708c0","title":"CPP第五次上机实验","content":"类微信通信。\n利用TCP&#x2F;IP技术，实现点对点通信，实现利用socket通信的连接、发送和接收；建立收发界面；收发需要同时；不必考虑安卓系统。\n需要解决的技术问题：\n（1）socket通信的基本原理耦合使用\n（2）多线程编程\n题目要求使用套接字（socket）实现TCP&#x2F;IP通信过程中的三次握手过程，建立客户端和用户端，完成客户端和用户的互相连通。\n完成多线程编程，实现收发同步。\n通信并发工作流程图\n程序难点及解决问题思路程序难点选择的是同步socket，是阻塞型的，平时写的单线程程序，在接收的时候无法进行发送，发送的时候无法进行接收。\nsocket的使用方法以及TCP&#x2F;IP协议的理解有一定难度。\n解决思路采用多线程编程，可以实现手法同步，使用WSAEnumNetworkEvents()函数可以实现多个操作的监控。\n思考如何实现多人聊天？完成程序已经实现了多人聊天，多个客户端可以向服务器发送消息，服务器存储了各个客户的socket和ip，然后进行向其他客户端的转发。\nTCP和UDP的关系？UDP可以用到微信中吗？是两种网络协议，tcp通过三次握手，保证了消息接收和正确性，UDP不对信心进行验证，只进行单发。微信是以消息传递为目的的，使用UDP协议难以保证消息的抵达和正确性，虽然加快了传输速度，但是得不偿失。\n代码实现https://github.com/LeoMeng86/JLU_cpp_experiment.git\n","slug":"CPP第五次上机实验","date":"2022-09-08T01:55:52.000Z","categories_index":"C&C++","tags_index":"CPP,编程","author_index":"Leo Meng"},{"id":"b294dc564007bd3ddd0057552526566b","title":"CPP第四次上机实验","content":"题目理解我对题目的理解是讲PPT中类的双向关联程序改为单向关联程序，并在main函数中调用。\n程序难点及解决思路本次的程序难点在于如何将双向关联改为单向关联，PPT中给出的方案是在Male类中设立一个静态的数组储存每一个新建的Male类，Male类中还储存了Female类，Female类定义一个Male* gethusband()函数通过访问Male的静态数组从而访问Male类，若此Male类中的Female类就是自身，则返回这个Male类。\n心得体会为了显示每一个Male类与Female类的对应关系，我在两类中加入了新的变量string name用于储存每一位的姓名，随后定义Male和Female类静态函数用于输出每一位对应关系，这样可以更直接的看出对应的关系。\n我的收获此次收获在于加深了对静态数据已经静态函数的了解。并且对类的相关学习有了更深的理解。\n代码实现https://github.com/LeoMeng86/JLU_cpp_experiment.git\n","slug":"CPP第四次上机实验","date":"2022-09-08T01:55:40.000Z","categories_index":"C&C++","tags_index":"CPP,编程","author_index":"Leo Meng"},{"id":"60136b05a7965396e962d3122dd90a33","title":"CPP第三次上机实验","content":"地图导航模拟算法。在一个无向图中任意给定两点实现最短路径计算。要求采用Dijkstra（深度或广度或Floyd或Bellman-Ford）算法，以及堆排序算法或其它排序算法，利用递归，vector支持邻接表方式，对于路径和选择路径进行界面显示（可仅仅显示而不交互）。主要目的：vector的理解，可视化编程的理解。\n题目要求后端要求完成任意指定两点的最短路径计算，采用最短路算法，使用堆优化或其它排序算法，优化最短路算法，使用vector存图的邻接表。\n前端要求对于图的路径以及选择路径进行界面展示，可以仅仅显示但是不交互。\n主要流程及解决思路主要流程1，写一个小根堆。\n2，建立Vertex类，储存图的邻接表。\n3，建立一个堆存 pair &amp;lt int ,int &amp;gt (cost, val) 存一个边集小根堆。\n4，利用堆写Dijkstra。\n5，建立EasyX界面，通过“建立地点”和“建立路线”或“文件读入”方式完成图的绘制。\n6，建立地点，在界面中以像素点进行标点，每次建点会向vector中进行一次push_back\n7，建立路线，输出起点和终点和边权，会完成邻接表的双向add，同时储存一个用于显示的边集。\n8，运行Dijkstra算法，计算路程，并把路线标红。\n解决思路要求使用简单的前端编程，对于C++，我已知的有EasyX和Qt。我在C语言课程设计中曾经使用过EasyX进行界面的设计，本次将继续使用EasyX完成相应的前端设计。要求使用求最短路的算法，因为题目要求，仅需要求给定两点之间的最短路，使用Floyd等最短路算法，求各源最短路有歼星炮打蚊子的感觉，本次选择了求单元最短路的Dijkstra算法，堆优化后可以达到O（mlogn）的级别，相比于Floyd的O(n^3）要优不少。\n程序的难点及遇到的问题使用EasyX时，为了可以将控制按键与画面分开，进行了setorigin操作，但是鼠标的检测，不随着setorigin进行改变，导致出现无法鼠标操控的情况，进行了较长时间的debug。\n程序的优缺点使用了堆优化的Dijkstra算法，效率较优。使用鼠标控制，实现了简单的交互功能，边权的设置不仅仅通过两点之间的距离，提高了自由度，有利于进一步考察交通等各种因素。\n我的收获进一步掌握了有关EasyX的相关操作，对可视化编程有了进一步的理解。通过图形化的展示，对Dijkstra算法有了更深的理解。\n代码实现https://github.com/LeoMeng86/JLU_cpp_experiment.git\n","slug":"CPP第三次上机实验","date":"2022-09-08T01:55:21.000Z","categories_index":"C&C++","tags_index":"CPP,编程","author_index":"Leo Meng"},{"id":"c943e7e0ca1458fff17cfd3d10a5007a","title":"CPP第二次上机实验","content":"题目要求要求使用类封装的知识，和重载函数，构造函数，析构函数等知识，完成对string类型的封装。构造函数实现直接定义一个空string，用已经定义的string复制一个新的string，定义一个n位’m’字符的string，或者截取已有string的一部分。重载方面实现了string类型的加法，赋值，下标访问，截取从strbegin，len长度的string，通过&lt;&lt;实现了流输出过程。\n主要流程及解决思路定义了CString类型，使用字符型（char）指针储存字符串的首地址，每次操作通过new函数申请空间，并delete[]掉之前的空间。使用重载函数，重载了+、&#x3D;、[]、()、&lt;&lt;等运算符，当两个string类型相加时候，使两个string串成一个，赋值时，将b的内容赋给a，并释放a之前申请的空间。为实现下标访问，重载了[]，实现了下标超界返回错误的设计。通过重载()，并传入两个int变量，截取了从strbegin共len位，通过友元并重载，完成&lt;&lt;，输出string内容的功能。\n程序难点以及我遇到的问题在重载(),实现截取功能时，对重载括号的虚参传入不熟悉，进行复习后，找到了相应的方法，犯了思维定式的错误，缺少派生的思想和能力。在重载&lt;&lt;时，开始没有使用友元，无法访问string中的内容，一度影响了输出的完成，通过进一步复习，顺利完成了相应函数。\n程序的优缺点圆满完成了老师布置的任务，和发布的相应测试。设置了不同方式的构造函数，使CString可以完成不同形式的初始化。使用了字符型指针的方法储存字符串的首指针的方法，进行动态申请字符型数组，并及时delete，相对于字符型数组减少了空间的损耗，相对于链表，减少了访问和删除时带来的复杂操作。缺点是，与stl中的string有较大差距，仅能实现其部分功能。\n我的收获再次复习了类封装的相关知识，进一步领会重载和友元的意义和用法，对STL中的string类型有了更深的了解。对类内类外的权限有了进一步掌握，希望可以进一步提升自己的编程能力，对面向对象概念有更深的理解。\n代码实现https://github.com/LeoMeng86/JLU_cpp_experiment.git\n","slug":"CPP第二次上机实验","date":"2022-09-08T01:55:00.000Z","categories_index":"C&C++","tags_index":"CPP,编程","author_index":"Leo Meng"},{"id":"303d0eaf42ba439d91837affe3563545","title":"CPP第一次上机实验","content":"题目要求第一个题目要求利用位运算的知识\n并通过位运算的方式完成十进制加减乘法；\n第二个题目要求计算1000！，结果超过两千位，远超int或者long long所能储存的值，应使用高精度乘法算法进行计算。\n主要流程及解决思路第一题：位运算共包括六种：与（&amp;）， 或（|）， 非（~），异或（^）， 左移（&lt;&lt;）, 右移（&gt;&gt;）。左移和右移运算可进行快速乘2，除2操作。\n\n\n\na\nb\na&amp;b\na|b\n~a\na^b\n\n\n\n0\n0\n0\n0\n1\n0\n\n\n0\n1\n0\n1\n1\n1\n\n\n1\n0\n0\n1\n0\n1\n\n\n1\n1\n1\n1\n0\n0\n\n\n根据该真值表可以进行位运算等操作。\n计算机通过补码进行运算，即无需考虑加负数的问题。根据上学期的数字逻辑知识，可知完成十进制加法器可以通过异或运算计算本位（异或运算当且仅当a！&#x3D;b时值为1），可计算出所有本位。再通过与运算计算出进位情况，当且仅当a &#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D; 1时值为1，符合运算进位的需求，此时进位保留在本位，应使用左移运算，完成进位操作，再循环进行进位与异或计算答案的异或，直到进位为0；\n减法运算，通过补码运算法则，对数据进行取补码运算先取反再加1，然后进行加法运算。乘法运算需要先判断a和b的正负，并转为正数，a*b，b个a相加，通过循环，完成b个a的相加运算，最后进行正负的判断。\n第二题：高精度计算，通过int数组，每个int存一位数，通过-1指示该位是否使用。\n高精度模拟了竖式计算法，完成按位相加后，需要维护数组的值在0到9之间。\n为操作方便，数据逆序存储，累乘操作需保存结果且乘数每次循环加1，完成后逆序输出。\n程序难点以及我遇到的问题第一题：之前未曾学习有关位运算实现的相关知识，只有去年学习的数字逻辑电路的知识进行辅助，未了解C++通过补码计算的规则，在进行加法运算时错误认为需要提前判断正负，导致减法运算时没有头绪。仔细完成相关知识学习之后，该问题迎刃而解。\n第二题：高精度加法和乘法的运用。\n程序的优缺点第一题：设置了较为合理的操作选项，完成了六种位运算封装并测试和三种十进制运算，使用迭代计算，减少了递归调用的时间损耗，减少堆栈的占用。\n第二题：使用int存位，使函数书写变得简洁，使用-1进行标识，方便了数位的判断，但使用memset()造成了时间的浪费。采用定长数组，在计算较小数的阶乘时，会造成空间的浪费。使用int存位相较于char存位，也造成了更大的浪费，若使用vector或者是string将进一步减少相关浪费。第一版将两个乘数全部使用高精度进行运算，浪费了空间和时间。在第二版中考虑到只有计算阶乘过程中第二个数不会出现爆int的情况，把第二个数直接以int形式乘到高精度数组中，然后进行数组维护，使程序更为简洁，提高了程序的效率。\n我的收获进一步学习了位运算，学习C&#x2F;C++中接近底层的操作。巩固了高精度算法的运用，在编程过程中可以更多的考虑空间和时间的占用。在debug过程中有效利用IDE自带调试功能，以及在关键位置输出结果的方式，进行了函数的测试和使用。在C语言课程设计过程中学习的相关开发知识，进一步得到夯实，由过程化编程，进一步学习了面向对象的思想，巩固了类封装的相关知识。希望今后可以进一步提升自己编程能力，进一步优化程序。\n代码实现https://github.com/LeoMeng86/JLU_cpp_experiment.git\n","slug":"CPP第一次上机实验","date":"2022-09-08T01:53:00.000Z","categories_index":"C&C++","tags_index":"CPP,编程","author_index":"Leo Meng"},{"id":"82c87e7d3d5a50c5b7d55245f7119e74","title":"数据结构第七次上机实验","content":"第一题：序列调度有一个N个数的序列A：1，2，……，N。有一个后进先出容器D，容器的容量为C。如果给出一个由1到N组成的序列，那么可否由A使用容器D的插入和删除操作得到。\n输入格式第1行，2个整数T和C，空格分隔，分别表示询问的组数和容器的容量，1≤T≤10，1≤C≤N。\n第2到T+1行，每行的第1个整数N，表示序列的元素数，1≤N≤10000。接下来N个整数，表示询问的序列。\n输出格式T行。若第i组的序列能得到，第i行输出Yes；否则，第i行输出No,1≤i≤T。\n输入样例在这里给出一组输入。例如：\n2 2\n5 1 2 5 4 3\n4 1 3 2 4\n\n输出样例在这里给出相应的输出。例如：\nNo\nYes\n\n题目解析方法一：栈模拟法代码实现#include&lt;iostream>\n#include&lt;vector>\n#include&lt;stack>\n\nusing namespace std;\n\nint t, c, cnt, key[10001];\n\nstack&lt;int> s;\n\nbool flag = true;\n\nint main()\n&#123;\n    scanf(\"%d%d\", &amp;t, &amp;c);\n    for(int i = 0; i &lt;= t - 1; i++)\n    &#123;\n        scanf(\"%d\", &amp;cnt);\n        flag = 1;\n        int top = 1;\n        while(!s.empty()) s.pop();\n        for(int j = 0; j &lt;= cnt - 1; j++)\n        &#123;\n            scanf(\"%d\", &amp;key[j]);\n        &#125;\n        for(int j = 0; j &lt;= cnt - 1; j++)\n        &#123;\n            if(!flag) continue;\n            while(key[j] >= top)\n            &#123;\n                s.push(top++);\n            &#125;\n            if(key[j] == top)\n            &#123;\n                top++;\n                continue;\n            &#125;\n            if(s.size() > c)\n            &#123;\n                flag = false;\n                break;\n            &#125;\n            if(key[j] &lt; top)\n            &#123;\n                if(s.top() == key[j])\n                &#123;\n                    s.pop();\n                    continue;\n                &#125;\n                else\n                &#123;\n                    flag = false;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        if(flag)\n        &#123;\n            printf(\"Yes\\n\");\n        &#125;\n        else printf(\"No\\n\");\n    &#125;\n\n    return 0;\n&#125;\n\n第二题：学院通知学院有n个学生，每个学生可以通知其余若干学生。通知不一定是相互的，即a能通知b、b不一定能通知a。\n现在，学院要发布一个重要的通知，必须通知学院的所有学生。问最少需要通知多少学生、才可能确保通知到学院里所有学生。\n输入格式第一行有两个整数n和m， 表示n 个学生（编号1~n）和m种通知方式，n≤500，m≤100000。\n以下m行，每行两个整数有a和b，表示a能通知b， 1≤a,b≤n。\n输出格式一行 最少需要通知的学生人数。\n输入样例在这里给出一组输入。例如：\n6 5\n1 2\n2 3\n3 1\n6 5\n6 5\n\n输出样例在这里给出相应的输出。例如：\n3\n\n题目解析方法一：tarjan算法求有向图强连通分量代码实现\n\n第三题：前缀查询已知有n个单词，单词均由小写字母构成。给出一个字符串，请统计以该字符串为前缀的单词的数量。规定：一个单词是其自身的前缀。单词和字符串都不空，长度都不超过20。\n输入格式第1行包含两个整数n和m，n≤10000,m≤10000，分别表示单词的个数和查询的个数。接下来的n行，每行一个单词。接下来的m行，每行一个字符串。\n输出格式多行，每行一个整数，对应查询字符串的统计数量。\n输入样例在这里给出一组输入。例如：\n2 2\nabc\nacd\na\nac\n\n输出样例在这里给出相应的输出。例如：\n2\n1\n\n题目解析方法一：字典树代码实现\n#include&lt;iostream>\n#include&lt;cstring>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, m, tot, tag[maxn];\nint trie[maxn][27];\n\nint getnum(char ch)\n&#123;\n    return ch - 'a' + 1;\n&#125;\n\nvoid insert(char *s)\n&#123;\n    int len = strlen(s + 1), p = 0;\n    for (int i = 1; i &lt;= len; i++)\n    &#123;\n        if (!trie[p][getnum(s[i])])\n            trie[p][getnum(s[i])] = ++tot;\n        p = trie[p][getnum(s[i])];\n        tag[p]++;\n    &#125;\n&#125;\n\nint query(char *s)\n&#123;\n    int len = strlen(s + 1), p = 0;\n    for (int i = 1; i &lt;= len; i++)\n    &#123;\n        if (!trie[p][getnum(s[i])])\n            return 0;\n        p = trie[p][getnum(s[i])];\n    &#125;\n    return tag[p];\n&#125;\n\nchar s[maxn];\n\nint main()\n&#123;\n    scanf(\"%d%d\", &amp;n, &amp;m);\n\n    for (int i = 1; i &lt;= n; i++)\n    &#123;\n        cin >> (s + 1);\n        insert(s);\n    &#125;\n\n    for (int i = 1; i &lt;= m; i++)\n    &#123;\n        cin >> (s + 1);\n        printf(\"%d\\n\", query(s));\n    &#125;\n&#125;\n\n\n第四题：数据结构设计I小唐正在学习数据结构。他尝试应用数据结构理论处理数据。最近，他接到一个任务，要求维护一个动态数据表，并支持如下操作：\n\n插入操作（I）：从表的一端插入一个整数。\n删除操作（D）：从表的另一端删除一个整数。\n取反操作（R）：把当前表中的所有整数都变成相反数。\n取最大值操作（M）：取当前表中的最大值。 如何高效实现这个动态数据结构呢？\n\n输入格式第1行，包含1个整数M，代表操作的个数， 2≤M≤1000000。\n第2到M+1行，每行包含1个操作。每个操作以一个字符开头，可以是I、D、R、M。如果是I操作，格式如下：I x, x代表插入的整数，-10000000≤x≤10000000。。\n输出格式若干行，每行1个整数，对应M操作的返回值。如果M和D操作时队列为空，忽略对应操作。\n输入样例在这里给出一组输入。例如：\n6\nI 6\nR\nI 2\nM\nD\nM\n\n输出样例在这里给出相应的输出。例如：\n2\n2\n\n题目解析方法一：multiset和deque使用bool变量flag控制取反操作，使用multiset求最大，deque进行队首队尾的删除操作。\n代码实现#include&lt;iostream>\n#include&lt;algorithm>\n#include&lt;queue>\n#include&lt;set>\n\nusing namespace std;\n\nmultiset&lt;int,greater&lt;int>> s;\nmultiset&lt;int,greater&lt;int>> s_con;\ndeque&lt;int> list;\ndeque&lt;int> list_con;\n\nint main()\n&#123;\n    bool flag=true;\n    int n=0;\n    scanf(\"%d\",&amp;n);getchar();\n    char choice=0;\n    int x=0;\n    for(int i=0;i&lt;n;++i)&#123;\n        scanf(\"%c\",&amp;choice);getchar();\n        if(choice=='I')&#123;\n            scanf(\"%d\",&amp;x);getchar();\n            list.push_front(flag?x:-x);\n            list_con.push_front(flag?-x:x);\n            s.insert(flag?x:-x);\n            s_con.insert(flag?-x:x);\n        &#125;else if(choice=='D')&#123;\n            if(!list.empty())&#123;\n                auto target=s.find(list.back());\n                auto target_con=s_con.find(list_con.back());\n                s.erase(target);\n                s_con.erase(target_con);\n                list.pop_back();\n                list_con.pop_back();\n            &#125;\n        &#125;else if (choice=='R')\n        &#123;\n            flag=!flag;\n\n        &#125;else if (choice=='M')\n        &#123;\n            if(!list.empty())&#123;\n                printf(\"%d\\n\",flag?*s.begin():*s_con.begin());\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n\n","slug":"数据结构第七次上机实验","date":"2022-09-06T04:32:32.000Z","categories_index":"数据结构","tags_index":"编程,数据结构","author_index":"Leo Meng"},{"id":"92dcc63de0a91e6ef330681692883b4c","title":"数据结构第六次上机实验","content":"第一题：稀疏矩阵之差矩阵A和B都是稀疏矩阵。请计算矩阵的差A-B.如果A、B不能计算差值，输出”Illegal!”\n输入格式矩阵的输入采用三元组表示，先A后B。对每个矩阵：\n第1行，3个整数N、M、t，用空格分隔，分别表示矩阵的行数、列数和非0数据项数，10≤N、M≤50000，t≤min(N,M).\n第2至t+1行，每行3个整数r、c、v，用空格分隔，表示矩阵r行c列的位置是非0数据项v, v在32位有符号整型范围内。三元组默认按行列排序。\n输出格式矩阵A-B，采用三元组表示，默认按行列排序，非零项也在32位有符号整型范围内。\n输入样例在这里给出一组输入。例如：\n10 10 3\n2 2 2\n5 5 5\n10 10 20\n10 10 2\n2 2 1\n6 6 6\n\n输出样例在这里给出相应的输出。例如：\n10 10 4\n2 2 1\n5 5 5\n6 6 -6\n10 10 20\n\n题目解析方法一：归并注意到题目给出的三元组已经按照行列排序，且输出要求也要求按照行列顺序，这里使用一个归并的方法，如果第一个矩阵的三元组小于第二个的，直接储存第一个，如果相等，输出相减后储存，如果第二个矩阵的三元组位置较小，储存第二个矩阵的相反数。\n里面有一个坑，相减后可能出现0的情况，一旦出现结果零，即不储存。\n#include &lt;iostream>\n#include &lt;vector>\n#include &lt;algorithm>\nusing namespace std;\nint main()\n&#123;\n    int CNT;\n    vector&lt;pair&lt;pair&lt;int, int>, int>> a, b, c;\n    int n, m, cnt;\n    cin >> n >> m >> cnt;\n    CNT = cnt;\n    while (cnt--)\n    &#123;\n        int tn, tm, val;\n        cin >> tn >> tm >> val;\n        auto tmp = pair&lt;int, int>(tn, tm);\n        a.push_back(pair&lt;pair&lt;int, int>, int>(tmp, val));\n    &#125;\n    int n2, m2, cnt2;\n    cin >> n2 >> m2 >> cnt2;\n    CNT += cnt2;\n    if (n2 != n || m != m2)\n    &#123;\n        cout &lt;&lt; \"Illegal!\";\n        return 0;\n    &#125;\n    while (cnt2--)\n    &#123;\n        int tn, tm, val;\n        cin >> tn >> tm >> val;\n        auto tmp = pair&lt;int, int>(tn, tm);\n        b.push_back(pair&lt;pair&lt;int, int>, int>(tmp, val));\n    &#125;\n    auto t1 = a.begin();\n    auto t2 = b.begin();\n    while (t1 != a.end() &amp;&amp; t2 != b.end())\n    &#123;\n        if (t1->first.first == t2->first.first)\n        &#123;\n            if (t2->first.second == t1->first.second)\n            &#123;\n                auto tmp = pair&lt;int, int>(t1->first.first, t1->first.second);\n                if (t1->second - t2->second != 0)\n                    c.push_back(pair&lt;pair&lt;int, int>, int>(tmp, t1->second - t2->second));\n                else\n                &#123;\n                    CNT--;\n                &#125;\n                t1++, t2++;\n                CNT--;\n            &#125;\n            else if (t1->first.second &lt; t2->first.second)\n            &#123;\n                auto tmp = pair&lt;int, int>(t1->first.first, t1->first.second);\n                c.push_back(pair&lt;pair&lt;int, int>, int>(tmp, t1->second));\n                t1++;\n            &#125;\n            else if (t1->first.second > t2->first.second)\n            &#123;\n                auto tmp = pair&lt;int, int>(t2->first.first, t2->first.second);\n                c.push_back(pair&lt;pair&lt;int, int>, int>(tmp, -t2->second));\n                t2++;\n            &#125;\n        &#125;\n        else if (t1->first.first &lt; t2->first.first)\n        &#123;\n            auto tmp = pair&lt;int, int>(t1->first.first, t1->first.second);\n            c.push_back(pair&lt;pair&lt;int, int>, int>(tmp, t1->second));\n            t1++;\n        &#125;\n        else if (t1->first.first > t2->first.first)\n        &#123;\n            auto tmp = pair&lt;int, int>(t2->first.first, t2->first.second);\n            c.push_back(pair&lt;pair&lt;int, int>, int>(tmp, -t2->second));\n            t2++;\n        &#125;\n    &#125;\n    while (t2 != b.end())\n    &#123;\n        auto tmp = pair&lt;int, int>(t2->first.first, t2->first.second);\n        c.push_back(pair&lt;pair&lt;int, int>, int>(tmp, -t2->second));\n        t2++;\n    &#125;\n    while (t1 != a.end())\n    &#123;\n        auto tmp = pair&lt;int, int>(t1->first.first, t1->first.second);\n        c.push_back(pair&lt;pair&lt;int, int>, int>(tmp, t1->second));\n        t1++;\n    &#125;\n    auto it = c.begin();\n    cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; m &lt;&lt; \" \" &lt;&lt; CNT &lt;&lt; \"\\n\";\n    while (it != c.end())\n    &#123;\n        cout &lt;&lt; it->first.first &lt;&lt; \" \" &lt;&lt; it->first.second &lt;&lt; \" \" &lt;&lt; it->second;\n        if (it + 1 != c.end())\n            cout &lt;&lt; \"\\n\";\n        it++;\n    &#125;\n    return 0;\n&#125;\n\n第二题：二叉树的最短路径长给定一棵二叉树T，每个结点赋一个权值。计算从根结点到所有结点的最短路径长度。路径长度定义为：路径上的每个顶点的权值和。\n输入格式第1行，1个整数n，表示二叉树T的结点数，结点编号1..n，1≤n≤20000。\n第2行，n个整数，空格分隔，表示T的先根序列，序列中结点用编号表示。\n第3行，n个整数，空格分隔，表示T的中根序列，序列中结点用编号表示。\n第4行，n个整数Wi，空格分隔，表示T中结点的权值，-10000≤Wi≤10000，1≤i≤n。\n输出格式1行，n个整数，表示根结点到其它所有结点的最短路径长度。\n输入样例在这里给出一组输入。例如：\n4\n1 2 4 3\n4 2 1 3\n1 -1 2 3\n\n输出样例在这里给出相应的输出。例如：\n1 0 3 3\n\n题目解析使用中根序列和先跟序列递归建树，然后DFS更新每个节点的最短路径长度。\n#include &lt;iostream>\nusing namespace std;\n\nint _val[20001];\nint result[20001] = &#123;0&#125;;\n\nstruct node\n&#123;\n    int val;\n    node *left;\n    node *right;\n&#125;;\n\nnode *build(int *pre, int *in, int size)\n&#123;\n    if (size &lt;= 0)\n        return nullptr;\n\n    int i;\n    for (i = 0; i &lt;= size - 1; i++)\n    &#123;\n        if (in[i] == pre[0])\n            break;\n    &#125;\n\n    node *tree = new node;\n    tree->val = pre[0];\n    tree->left = build(pre + 1, in, i);\n    tree->right = build(pre + i + 1, in + i + 1, size - 1 - i);\n    return tree;\n&#125;\n\nvoid DFS(node * root, int cost)\n&#123;\n    if(root == nullptr) return;\n    result[root->val] = cost + _val[root->val];\n    DFS(root->left, result[root->val]);\n    DFS(root->right, result[root->val]);\n&#125;\n\nint main()\n&#123;\n    int n;\n    scanf(\"%d\", &amp;n);\n    int _pre[20001], _in[20001];\n\n    for(int i = 0; i &lt;= n - 1; i++)\n    &#123;\n        scanf(\"%d\", &amp;_pre[i]);\n    &#125;\n\n    for(int i = 0; i &lt;= n - 1; i++)\n    &#123;\n        scanf(\"%d\", &amp;_in[i]);\n    &#125;\n\n    for(int i = 1; i &lt;= n; i++)\n    &#123;\n        scanf(\"%d\", &amp;_val[i]);\n    &#125;\n\n    node* root = build(_pre,_in,n);\n\n    DFS(root, 0);\n\n    for(int i = 1; i &lt;= n; i++)\n    &#123;\n        printf(\"%d\", result[i]);\n        if(i != n) printf(\" \");\n    &#125;\n    printf(\"\\n\");\n&#125;\n\n第三题：文字编辑一篇文章由n个汉字构成，汉字从前到后依次编号为1，2，……，n。有四种操作：\nA i j表示把编号为i的汉字移动编号为j的汉字之前；\nB i j表示把编号为i的汉字移动编号为j的汉字之后；\nQ 0 i为询问编号为i的汉字之前的汉字的编号；\nQ 1 i为询问编号为i的汉字之后的汉字的编号。\n规定：1号汉字之前是n号汉字，n号汉字之后是1号汉字。\n输入格式第1行，1个整数T，表示有T组测试数据， 1≤T≤9999.\n随后的每一组测试数据中，第1行两个整数n和m，用空格分隔，分别代表汉字数和操作数，2≤n≤9999，1≤m≤9999；第2至m+1行，每行包含3个常量s、i和j，用空格分隔，s代表操作的类型，若s为A或B，则i和j表示汉字的编号，若s为Q，i代表0或1，j代表汉字的编号。\n输出格式若干行，每行1个整数，对应每个询问的结果汉字编号。\n输入样例在这里给出一组输入。例如：\n1\n9999 4\nB 1 2\nA 3 9999\nQ 1 1\nQ 0 3\n\n输出样例在这里给出相应的输出。例如：\n4\n9998\n\n题目解析方法一：跳舞链实现定点插入，定点查询，定点删除，且能满足1000ms的时间限制，使用跳舞链会比较合适。\n本题使用静态链表实现，会比较好写。\n#include &lt;iostream>\n#include &lt;algorithm>\nusing namespace std;\nint main()\n&#123;\n    int T;\n    scanf(\"%d\", &amp;T);\n    int pre[100001];\n    int nxt[100001];\n    int n, m;\n    for (register int j = 0; j &lt;= T - 1; j++)\n    &#123;\n        scanf(\"%d%d\", &amp;n, &amp;m);\n        for (register int i = 1; i &lt;= n; i++)\n        &#123;\n\n            pre[i] = i - 1;\n            nxt[i] = i + 1;\n        &#125;\n        pre[1] = n;\n        nxt[n] = 1;\n        for (register int k = 0; k &lt;= m - 1; k++)\n        &#123;\n            char ch;\n            int op1, op2;\n            cin >> ch;\n            scanf(\"%d%d\", &amp;op1, &amp;op2);\n            switch (ch)\n            &#123;\n            case 'A':\n            &#123;\n                nxt[pre[op1]] = nxt[op1];\n                pre[nxt[op1]] = pre[op1];\n                pre[op1] = pre[op2];\n                nxt[op1] = op2;\n                nxt[pre[op2]] = op1;\n                pre[op2] = op1;\n                break;\n            &#125;\n            case 'B':\n            &#123;\n                nxt[pre[op1]] = nxt[op1];\n                pre[nxt[op1]] = pre[op1];\n                pre[op1] = op2;\n                nxt[op1] = nxt[op2];\n                pre[nxt[op2]] = op1;\n                nxt[op2] = op1;\n                break;\n            &#125;\n            case 'Q':\n            &#123;\n                switch (op1)\n                &#123;\n                case 0:\n                &#123;\n                    printf(\"%d\\n\", pre[op2]);\n                    break;\n                &#125;\n                case 1:\n                &#123;\n                    printf(\"%d\\n\", nxt[op2]);\n                    break;\n                &#125;\n                &#125;\n                break;\n            &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n第四题：方案计数组装一个产品需要 n 个零件。生产每个零件都需花费一定的时间。零件的生产可以并行进行。有些零件的生产有先后关系，只有一个零件的之前的所有零件都生产完毕，才能开始生产这个零件。如何合理安排工序，才能在最少的时间内完成所有零件的生产。在保证最少时间情况下，关键方案有多少种，关键方案是指从生产开始时间到结束时间的一个零件生产序列，序列中相邻两个零件的关系属于事先给出的零件间先后关系的集合，序列中的每一个零件的生产都不能延期。\n输入格式第1行，2个整数n和m，用空格分隔，分别表示零件数和关系数，零件编号1..n，1≤n≤10000, 0≤m≤100000 。\n第2行，n个整数Ti，用空格分隔，表示零件i的生产时间，1≤i≤n，1≤Ti≤100 。\n输出格式第1行，1个整数，完成生产的最少时间。\n第2行，1个整数，关键方案数，最多100位。\n如果生产不能完成，只输出1行，包含1个整数0.\n输入样例在这里给出一组输入。例如：\n4 4\n1 2 2 1\n1 2\n1 3\n2 4\n3 4\n\n输出样例在这里给出相应的输出。例如：\n4\n2\n\n题目解析方法一：拓扑排序+关键路径+高精度感谢mxgg，上次有一个题目一直段错误，mxgg发现是我爆了int，建议我以后#define int long long, 我说以后不是BigInteger我都不用，然后就机缘巧合向大佬学习写了BigInt的板子，mxgg yyds！！！\n除了需要高精度，读图时候，需要点权推到边权上，并把入度为0的点引到虚源，出度为0的点汇到虚源上，形成连通图，然后拓扑排序和关键路径算法。\n对于我这种蒟蒻，存板子就是我白月光！！！膜拜手拍大佬！！！\n#include&lt;iostream>\n#include&lt;string>\n#include&lt;limits>\n#include&lt;queue>\n#include&lt;vector>\n#include&lt;algorithm>\nusing namespace std;\n\nclass Bigint\n&#123;\nprivate:\n    vector&lt;int> content;\npublic:\n    Bigint();\n    Bigint(long long origin);\n    Bigint(const Bigint&amp; b);\n    ~Bigint();\n    unsigned long long size() const;\n    Bigint operator+(const Bigint&amp; b);\n    Bigint&amp; operator=(const Bigint&amp; b);\n    void resize(unsigned long long n);\n    const int&amp; operator[](unsigned long long i)const;\n    int&amp; operator[](unsigned long long i);\n    string toString();\n&#125;;\n\nBigint::Bigint()&#123;\n    content.reserve(128);\n    for (int i = 0; i &lt; 128; ++i)&#123;\n        content.push_back(0);\n    &#125;\n\n&#125;\n\nBigint::Bigint(long long origin)&#123;\n    content.reserve(128);\n    while (origin>0)\n    &#123;\n        content.push_back(origin%10);\n        origin=origin/10;\n    &#125;\n&#125;\nBigint::Bigint(const Bigint&amp; b)&#123;\n    content.clear();\n    for(int i=0;i&lt;b.size();++i)&#123;\n        content.push_back(b[i]);\n    &#125;\n&#125;\n\nBigint::~Bigint()&#123;\n    content.clear();\n&#125;\n\nBigint Bigint::operator+(const Bigint&amp; b)&#123;\n    Bigint t;\n    Bigint res;\n    unsigned long long maxsize=max(this->size(),b.size());\n    t.resize(maxsize+1);\n    res.resize(maxsize+1);\n    for (int i = 0; i &lt; maxsize; ++i)&#123;\n        int num1=i&lt;this->size()?content[i]:0;\n        int num2=i&lt;b.size()?b[i]:0;\n        res[i]=(num1+num2+t[i])%10;\n        t[i+1]=(num1+num2+t[i])/10;\n    &#125;\n    if(t[maxsize]!=0)&#123;\n        res[maxsize]=t[maxsize];\n    &#125;else&#123;\n        res.resize(maxsize);\n    &#125;\n    return res;\n&#125;\n\nBigint&amp; Bigint::operator=(const Bigint&amp; b)&#123;\n    if(this==&amp;b)&#123;\n        return *this;\n    &#125;else&#123;\n        content.clear();\n        content.reserve(b.size());\n        for(int i=0;i&lt;b.size();++i)&#123;\n            content.push_back(b[i]);\n        &#125;\n    &#125;\n    return *this;\n&#125;\n\nunsigned long long Bigint::size()const&#123;\n        return content.size();\n&#125;\n\nconst int&amp; Bigint::operator[](unsigned long long i)const&#123;\n    if(i>content.size())return *content.end();\n    return (*(content.begin()+i));\n&#125;\n\nint&amp; Bigint::operator[](unsigned long long i)&#123;\n    if(i>content.size())return *content.end();\n    return (*(content.begin()+i));\n&#125;\n\nvoid Bigint::resize(unsigned long long n)&#123;\n    if(n>this->size())&#123;\n        for (unsigned long long i = this->size(); i &lt;n; ++i)&#123;\n            content.push_back(0);\n        &#125;\n    &#125;else&#123;\n        for (unsigned long long i = this->size(); i>n; --i)&#123;\n            content.pop_back();\n        &#125;\n    &#125;\n&#125;\n\nstring Bigint::toString()&#123;\n    bool flag=true;\n    string res;\n    for (int i = this->size()-1; i >=0; --i)&#123;\n        if(flag&amp;&amp;content[i]==0)&#123;\n            continue;\n        &#125;else&#123;\n            if(flag&amp;&amp;content[i]!=0)&#123;\n                flag=false;\n            &#125;\n            res.push_back(content[i]+48);\n        &#125;\n    &#125;\n    if(flag)res.push_back('0');\n    return res;\n&#125;\n\nconst int maxn = 10010;\nint n = 0, m = 0;\n\nint inDu[maxn] = &#123;0&#125;;\nint inDu_bfs[maxn] = &#123;0&#125;;\nint outDu[maxn] = &#123;0&#125;;\nint es[maxn] = &#123;0&#125;;\nint ls[maxn];\nint cs[maxn] = &#123;0&#125;;\n\nstruct Node\n&#123;\n    Node* nxt;\n    int val;\n    int cost;\n    Node(int _val = 0, int _cost = 0)\n    &#123;\n        cost = _cost;\n        val = _val;\n        nxt = nullptr;\n    &#125;\n&#125;;\n\nNode *phead[maxn] = &#123;nullptr&#125;, *ptail[maxn] = &#123;nullptr&#125;;\n\nvoid add(int _fr, int _to, int _cost)\n&#123;\n    Node *t = ptail[_fr];\n    if (t == nullptr)\n    &#123;\n        phead[_fr] = new Node(_to,_cost);\n        ptail[_fr] = phead[_fr];\n    &#125;\n    else\n    &#123;\n        ptail[_fr]->nxt = new Node(_to, _cost);\n        ptail[_fr] = ptail[_fr]->nxt;\n    &#125;\n    outDu[_fr]++;\n    inDu[_to]++;\n    inDu_bfs[_to]++;\n\n&#125;\n\nvoid read_map()\n&#123;\n    for(int i = 1; i &lt;= n ; i++)\n    &#123;\n        scanf(\"%d\", &amp;cs[i]);\n    &#125;\n    int _fr = 0, _to = 0;\n    for(int i  = 0; i &lt;= m - 1; i++)\n    &#123;\n        scanf(\"%d%d\", &amp;_fr, &amp;_to);\n        add(_fr, _to, cs[_to]);\n    &#125;\n\n    for(int i = 1; i &lt;= n; i++)\n    &#123;\n        if(inDu[i] == 0)\n        &#123;\n            add(0,i,cs[i]);\n        &#125;\n        if(outDu[i] == 0)\n        &#123;\n            add(i, n + 1, 0);\n        &#125;\n    &#125;\n&#125;\n\nvector&lt;int> topo_result;\nvoid topo()\n&#123;\n    queue&lt;int> q;\n    topo_result.reserve(maxn);\n    q.push(0);\n    while(!q.empty())\n    &#123;\n        int now = q.front();\n        q.pop();\n        topo_result.push_back(now);\n        for(auto it = phead[now]; it!= nullptr; it= it->nxt)\n        &#123;\n            int to = it->val;\n            int cost = it->cost;\n            inDu[to]--;\n            if(inDu[to] == 0)\n            &#123;\n                q.push(to);\n            &#125;\n            es[to] = max(es[now] + cost, es[to]);\n        &#125;\n    &#125;\n&#125;\n\nvoid Cpath()\n&#123;\n    topo();\n    ls[n+1] = es[n+1];\n    for(int i = topo_result.size() - 1; i >= 0; i--)\n    &#123;\n        int now = topo_result[i];\n        for(auto it = phead[now]; it != nullptr; it = it->nxt)\n        &#123;\n            int to = it->val;\n            int cost = it->cost;\n            ls[now] = min(ls[to]-cost, ls[now]);\n        &#125;\n    &#125;\n&#125;\n\nBigint tmp[maxn];\nBigint res;\nint vis[maxn] = &#123;0&#125;;\n\nvoid bfs(int x)\n&#123;\n    queue&lt;int> q;\n    q.push(x);\n    vis[x] = 1;\n    while(!q.empty())\n    &#123;\n        int now = q.front();\n        q.pop();\n        vis[now] = 1;\n        for(auto it = phead[now]; it != nullptr; it = it->nxt)\n        &#123;\n            int to = it->val;\n            inDu_bfs[to]--;\n            if(es[to] == ls[to])\n            &#123;\n                tmp[to] = tmp[now] + tmp[to];\n            &#125;\n            if(inDu_bfs[to] == 0)\n            &#123;\n                q.push(to);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    for(int i = 0; i &lt;= maxn - 1; i++)\n    &#123;\n        ls[i] = INT32_MAX;\n    &#125;\n    scanf(\"%d%d\", &amp;n, &amp;m);\n    read_map();\n    Cpath();\n    tmp[0] = 1;\n    bfs(0);\n    long long result = es[n+1];\n    res = tmp[n+1];\n    if(res.toString() != \"0\") cout &lt;&lt; result &lt;&lt;endl;\n    cout &lt;&lt; res.toString() &lt;&lt; endl;\n    return 0;\n&#125;","slug":"数据结构第六次上机实验","date":"2022-09-06T04:02:32.000Z","categories_index":"数据结构","tags_index":"编程,数据结构","author_index":"Leo Meng"},{"id":"11dfa7e5794f08feee18d1b7215f1a65","title":"数据结构第五次上机实验","content":"第一题：重复计数在一个有限的正整数序列中，有些数会多次重复出现。请你统计每个数的出现次数，然后按数字在序列中第一次出现的位置顺序输出数及其次数。\n输入格式第1行，1个整数N，表示整数的个数，(1≤N≤50000)。\n第2行，N个正整数，每个整数x 都满足 1 ≤ x ≤2000000000。\n输出格式若干行，每行两个用一个空格隔开的数，第一个是数列中出现的数，第二个是该数在序列中出现的次数。\n输入样例在这里给出一组输入。例如：\n12\n8 2 8 2 2 11 1 1 8 1 13 13\n\n输出样例在这里给出相应的输出。例如：\n8 3\n2 3\n11 1\n1 3\n13 2\n\n题目解析方法一：STLSTL大法好，map的find时间复杂度是log级别，找到了会返回目标的迭代器，找不到会返回end()，然后用一个queue来存顺序，STL我的神！！！\n代码实现#include &lt;iostream>\n#include &lt;algorithm>\n#include &lt;map>\n#include &lt;queue>\nusing namespace std;\n\nint main()\n&#123;\n    int n, tmp;\n    scanf(\"%d\", &amp;n);\n    map&lt;int, int> m;\n    queue&lt;int> Q;\n    while (n--)\n    &#123;\n        scanf(\"%d\", &amp;tmp);\n        auto it = m.find(tmp);\n        if (it == m.end())\n        &#123;\n            Q.push(tmp);\n            m.insert(pair&lt;int, int>(tmp, 1));\n        &#125;\n        else\n            it->second++;\n    &#125;\n    while (!Q.empty())\n    &#123;\n        auto it = m.find(Q.front());\n        Q.pop();\n        cout &lt;&lt; it->first &lt;&lt; \" \" &lt;&lt; it->second;\n        m.erase(it);\n        if (Q.size() >= 1)\n            cout &lt;&lt; \"\\\\n\";\n    &#125;\n    return 0;\n&#125;\n\n第二题：字符串周期一个字符串可以看成由某个长度为k的前缀重复若干次得到，称k为该字符串的周期。例如：”abababab”以2、4、8为周期。请计算一个字符串的最小周期。\n输入格式输入包含多行。每行包含一个字符串s，s至少1个字符，最多1000000个字符。最后一行是一个点，表示输入结束，不必求解。输入较大，建议使用scanf。\n输出格式多行，每行一个整数，对应每一行输入s的最小周期。\n输入样例在这里给出一组输入。例如：\nabcd\naaaa\nababab\n.\n\n输出样例在这里给出相应的输出。例如：\n4\n1\n2\n\n题目解析方法一：朴素匹配感觉应该过不了，没有写，刚讲了kmp，估计用kmp才是正解（doge）；\n方法二：KMP本题目我选择了next数组的方法。即求前后缀的最大匹配值。\n#include &lt;iostream>\n#include &lt;cstring>\nusing namespace std;\nconst int num = 1000001;\nvoid Next(char *s, int next[])\n&#123;\n    next[0] = -1;\n    int k = -1;\n    int j = 0;\n    int len = strlen(s);\n\n    while (j &lt; len)\n    &#123;\n        if (k == -1 || s[j] == s[k])\n        &#123;\n            ++k;\n            ++j;\n            next[j] = k;\n        &#125;\n        else\n        &#123;\n            k = next[k];\n        &#125;\n    &#125;\n&#125;\n\nint MinCycle(char *s)\n&#123;\n\n    int next[num];\n    Next(s, next);\n\n    int len = strlen(s);\n    int mclen = len - next[len];\n    return mclen;\n&#125;\n\nint main()\n&#123;\n    char s[1000001];\n    while (1)\n    &#123;\n        scanf(\"%s\", s);\n        if (strcmp(s, \".\") == 0)\n            break;\n        cout &lt;&lt; MinCycle(s) &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;\n\n第三题：交换次数序列A中有N个整数。\n求对A进行冒泡排序发生的元素交换次数。\n输入格式第一行输入整数N(2&lt;&#x3D;N&lt;&#x3D;10^6).接下来一行N个正整数数A[i] (1≤i≤N ，A[i]&lt;&#x3D;10^6)。\n输出格式一行，有一个整数，表示元素交换的次数。\n输入样例在这里给出一组输入。例如：\n4\n2 4 3 1\n\n输出样例在这里给出相应的输出。例如：\n4\n\n题目解析方法一：树状数组冒泡排序的交换次数，取决于逆序数的数量，本题目使用树状数组计算逆序数，树状数组和线段树类似，可以实现单点更新单点查询，单点更新区间查询，区间更新单点查询，区间更新区间查询。\n#include&lt;iostream>\nusing namespace std;\n\nconst int maxn = 1e6 +10;\n\nint n;\nint bit[maxn];\nint a[maxn];\n\nint sum(int i)\n&#123;\n    int s = 0;\n    while(i>0)&#123;\n        s += bit[i];\n        i -= i &amp; -i;\n    &#125;\n    return s;\n&#125;\n\nvoid add(int i)\n&#123;\n    while(i&lt;=maxn)&#123;\n        bit[i] += 1;\n        i += i &amp; -i;\n    &#125;\n&#125;\n\nvoid solve()\n&#123;\n    long long ans = 0;\n    for(int j = 0;j&lt;n;j++)&#123;\n        ans += j - sum(a[j]);\n        add(a[j]);\n    &#125;\n    printf(\"%lld\\\\n\",ans);\n&#125;\n\nint main()&#123;\n    scanf(\"%d\",&amp;n);\n    for(int i=0;i&lt;n;i++)&#123;\n        scanf(\"%d\",&amp;a[i]);\n    &#125;\n    solve();\n    return 0;\n&#125;\n\n第四题：维护序列一个序列初始为空。给出N(N&lt;&#x3D;1000000)个操作维护序列。\n输入格式第1行 整数N；然后有N行，每行两个数，ch和kch&#x3D;1表示插入一个值为k的数ch&#x3D;2表示查询第k小的数（k合法）ch&#x3D;3表示删除值为k的数(k一定存在)\n输出格式输出查询操作的结果值。每个一行。\n输入样例在这里给出一组输入。例如：\n5\n1 2\n1 3\n2 1\n3 2\n2 1\n\n输出样例在这里给出相应的输出。例如：\n2\n3\n\n题目解析能满足插入值为k的数，查询第k小的数，删除值为k的数的数据结构，限制1000ms，应该选择高度平衡树。据说还卡splay，没有写过类似的板子，看到这个题目，简直绝望，用暴力法骗了20分，只能下课请教大佬。感谢mxgg和zygg提供的treap的解法和帮我一起debug，我哭死。\ntreap是树堆，比较容易实现，比较基础，且常数不大。有BST的性质，也有Heap的性质，可以维护排名，又能保证深度在logn级别。\n#include&lt;bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e7 + 7;\nconst int mod = 1e7 + 7;\n\nstruct node\n&#123;\n\tint key, rd, pl, pr, size;\n&#125; tree[maxn];\n\nint sz, root;\n\ninline void maintain(int x)\n&#123;\n\ttree[x].size = tree[tree[x].pl].size + tree[tree[x].pr].size + 1;\n&#125;\n\ninline void R_rorate(int &amp;p)\n&#123;\n\tint ii = tree[p].pl;\n\ttree[p].pl = tree[ii].pr;\n\ttree[ii].pr = p;\n\ttree[ii].size = tree[p].size;\n\tmaintain(p);\n\tp = ii;\n&#125;\n\ninline void L_rorate(int &amp;p)\n&#123;\n\tint ii = tree[p].pr;\n\ttree[p].pr = tree[ii].pl;\n\ttree[ii].pl = p;\n\ttree[ii].size = tree[p].size;\n\tmaintain(p);\n\tp = ii;\n&#125;\n\ninline void insert(int &amp;p, int x)\n&#123;\n\tif (p == 0)\n\t&#123;\n\t\tp = ++sz;\n\t\ttree[p].size = 1;\n\t\ttree[p].key = x;\n\t\ttree[p].rd = rand() * rand() % mod;\n\t\treturn;\n\t&#125;\n\ttree[p].size++;\n\tif (x >= tree[p].key)\n\t&#123;\n\t\tinsert(tree[p].pr, x);\n\t&#125;\n\telse\n\t&#123;\n\t\tinsert(tree[p].pl, x);\n\t&#125;\n\tif (tree[p].pl != 0 &amp;&amp; tree[p].rd > tree[tree[p].pl].rd)\n\t&#123;\n\t\tR_rorate(p);\n\t&#125;\n\tif (tree[p].pr != 0 &amp;&amp; tree[p].rd > tree[tree[p].pr].rd)\n\t&#123;\n\t\tL_rorate(p);\n\t&#125;\n\tmaintain(p);\n&#125;\n\ninline void remove(int &amp;p, int x)\n&#123;\n\ttree[p].size--;\n\tif(tree[p].key == x)\n\t&#123;\n\t\tif (tree[p].pl == 0 &amp;&amp; tree[p].pr == 0)\n\t\t&#123;\n\t\t\tp = 0;\n\t\t\treturn;\n\t\t&#125;\n\t\tif (tree[p].pl == 0 || tree[p].pr == 0)\n\t\t&#123;\n\t\t\tp = tree[p].pl + tree[p].pr;\n\t\t\treturn;\n\t\t&#125;\n\t\tif (tree[tree[p].pl].rd &lt; tree[tree[p].pr].rd)\n\t\t&#123;\n\t\t\tR_rorate(p);\n\t\t\tremove(tree[p].pr, x);\n\t\t\treturn;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tL_rorate(p);\n\t\t\tremove(tree[p].pl, x);\n\t\t\treturn;\n\t\t&#125;\n\t&#125;\n\n\tif (tree[p].key &lt;= x)\n\t&#123;\n\t\tremove(tree[p].pr, x);\n\t&#125;\n\telse\n\t&#123;\n\t\tremove(tree[p].pl, x);\n\t&#125;\n\tmaintain(p);\n&#125;\n\ninline int kth(int p, int x)\n&#123;\n\tif (x == tree[tree[p].pl].size + 1)\n\t&#123;\n\t\treturn tree[p].key;\n\t&#125;\n\tif (x > tree[tree[p].pl].size + 1)\n\t&#123;\n\t\treturn kth(tree[p].pr, x - tree[tree[p].pl].size - 1);\n\t&#125;\n\treturn kth(tree[p].pl, x);\n&#125;\n\nint main()\n&#123;\n\tios::sync_with_stdio(false); cin.tie(nullptr);\n\tsrand(mod);\n\tint n;\n\tscanf(\"%d\", &amp;n);\n\tint ch, ch1;\n\tfor (int i = 1; i &lt;= n; i++)\n\t&#123;\n\t\tscanf(\"%d%d\", &amp;ch, &amp;ch1);\n\t\tswitch (ch)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tinsert(root, ch1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"%d\\\\n\", kth(root, ch1));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tremove(root, ch1);\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n","slug":"数据结构第五次上机实验","date":"2022-09-06T04:02:18.000Z","categories_index":"数据结构","tags_index":"编程,数据结构","author_index":"Leo Meng"},{"id":"7d8e8db1d60b240c8f6df95f6b0082a1","title":"数据结构第四次上机实验","content":"第一题： 图的深度优先搜索I无向图 G 有 n 个顶点和 m 条边。求图G的深度优先搜索树(森林)以及每个顶点的发现时间和完成时间。每个连通分量从编号最小的结点开始搜索，邻接顶点选择顺序遵循边的输入顺序。\n在搜索过程中，第一次遇到一个结点，称该结点被发现；一个结点的所有邻接结点都搜索完，该结点的搜索被完成。深度优先搜索维护一个时钟，时钟从0开始计数，结点被搜索发现或完成时，时钟计数增1，然后为当前结点盖上时间戳。一个结点被搜索发现和完成的时间戳分别称为该结点的发现时间和完成时间\n输入格式第1行，2个整数n和m，用空格分隔，分别表示顶点数和边数， 1≤n≤50000， 1≤m≤100000.\n第2到m+1行，每行两个整数u和v，用空格分隔，表示顶点u到顶点v有一条边，u和v是顶点编号，1≤u,v≤n.\n输出格式第1到n行，每行两个整数di和fi，用空格分隔，表示第i个顶点的发现时间和完成时间1≤i≤n 。\n第n+1行，1个整数 k ，表示图的深度优先搜索树(森林)的边数。\n第n+2到n+k+1行，每行两个整数u和v,表示深度优先搜索树(森林)的一条边&lt;u,v&gt;，边的输出顺序按 v 结点编号从小到大。\n输入样例在这里给出一组输入。例如：\n6 5\n1 3\n1 2\n2 3\n4 5\n5 6\n\n输出样例在这里给出相应的输出。例如：\n1 6\n3 4\n2 5\n7 12\n8 11\n9 10\n4\n3 2\n1 3\n4 5\n5 6\n\n题目解析方法一：深度优先遍历根据题目说的用DFS，使用一个timer来标识时间，然后用数组存每一个节点的进入时间和离开时间。\n代码实现DFS每个DFS的点要用用vis数组标志访问情况，然后用timer给intime赋值，该节点遍历完成后，再用timer给outtime赋值。\nvoid dfs(int x)\n&#123;\n    vis[x] = 1;\n    intime[x] = ++timer;\n\n    node *p = phead[x];\n\n    while(p != nullptr)\n    &#123;\n        if(vis[p->val] != 1)\n        &#123;\n            list.push(edge(x,p->val));\n            dfs(p->val);\n        &#125;\n        p = p->next;\n    &#125;\n\n    outtime[x] = ++timer;\n&#125;\n\n完整代码#include &lt;iostream>\n#include &lt;vector>\n#include &lt;queue>\nusing namespace std;\n\nint timer = 0;\nint intime[50001] = &#123;0&#125;, outtime[50001] = &#123;0&#125;;\nint n, m, v1, v2;\nint vis[50001] = &#123;0&#125;;\n\nclass node\n&#123;\npublic:\n    int val;\n    node *next;\n    node(int _v)\n    &#123;\n        val = _v;\n        next = nullptr;\n    &#125;\n&#125;;\n\nnode *phead[50001] = &#123;nullptr&#125;;\nnode *ptail[50001] = &#123;nullptr&#125;;\n\nclass edge\n&#123;\npublic:\n    int u, v;\n    edge(int u_tmp, int v_tmp) : u(u_tmp), v(v_tmp)&#123;&#125;;\n    bool operator&lt;(const edge &amp;b) const\n    &#123;\n        return v > b.v;\n    &#125;\n&#125;;\n\npriority_queue&lt;edge> list;\n\nvoid add(int &amp;a, int &amp;b)\n&#123;\n    node *t = ptail[a];\n    if (t == nullptr)\n    &#123;\n        phead[v1] = new node(v2);\n        ptail[v1] = phead[v1];\n    &#125;\n    else\n    &#123;\n        ptail[v1]->next = new node(v2);\n        ptail[v1] = ptail[v1]->next;\n    &#125;\n\n    t = ptail[v2];\n    if (t == nullptr)\n    &#123;\n        phead[v2] = new node(v1);\n        ptail[v2] = phead[v2];\n    &#125;\n    else\n    &#123;\n        ptail[v2]->next = new node(v1);\n        ptail[v2] = ptail[v2]->next;\n    &#125;\n&#125;\n\nvoid dfs(int x)\n&#123;\n    vis[x] = 1;\n    intime[x] = ++timer;\n\n    node *p = phead[x];\n\n    while (p != nullptr)\n    &#123;\n        if (vis[p->val] != 1)\n        &#123;\n            list.push(edge(x, p->val));\n            dfs(p->val);\n        &#125;\n        p = p->next;\n    &#125;\n\n    outtime[x] = ++timer;\n&#125;\n\nint main()\n&#123;\n    scanf(\"%d%d\", &amp;n, &amp;m);\n\n    for (int i = 0; i &lt;= m - 1; i++)\n    &#123;\n        scanf(\"%d%d\", &amp;v1, &amp;v2);\n        add(v1, v2);\n    &#125;\n\n    for (int i = 1; i &lt;= n; i++)\n    &#123;\n        if (vis[i] != 1)\n        &#123;\n            dfs(i);\n        &#125;\n    &#125;\n\n    for (int i = 1; i &lt;= n; i++)\n    &#123;\n        printf(\"%d %d\\\\n\", intime[i], outtime[i]);\n    &#125;\n    cout &lt;&lt; list.size() &lt;&lt; endl;\n    while (!list.empty())\n    &#123;\n        printf(\"%d %d\\\\n\", list.top().u, list.top().v);\n        list.pop();\n    &#125;\n    return 0;\n&#125;\n\n教训把各个函数都改了一遍，发现oj居然卡cin和cout，不要用cin或者cout还有endl，会变得不幸。\n第二题：数字变换利用变换规则，一个数可以变换成另一个数。变换规则如下：（1）x 变为x+1；（2）x 变为2x；（3）x 变为 x-1。给定两个数x 和 y，至少经过几步变换能让 x 变换成 y.\n输入格式1行，2个整数x和y，用空格分隔， 1≤x,y≤100000.\n输出格式第1行，1个整数s，表示变换的最小步数。\n第2行，s个数，用空格分隔，表示最少变换时每步变换的结果。规则使用优先级顺序: （1），（2），（3）。\n输入样例在这里给出一组输入。例如\n2 14\n\n输出样例在这里给出相应的输出。例如：\n4\n3 6 7 14\n\n题目解析无权无限图最短路问题，为防止两种不同步骤产生相同答案的重复计算，使用vis数组标志已访问变量，答案用path数组记录，输出时是逆序，应使用stack存储后，正序输出。\n方法一：广度优先遍历BFSvoid bfs(int x, int y)\n&#123;\n    queue&lt;int> q;\n    q.push(x);\n    while(!q.empty())\n    &#123;\n        int tmp = q.front();\n        q.pop();\n        if(tmp + 1 &lt;= maxn &amp;&amp; path[tmp+1] == tmp + 1)\n        &#123;\n            q.push(tmp + 1);\n            path[tmp + 1] = tmp;\n            if(tmp + 1 == y) return;\n        &#125;\n        if(tmp * 2 &lt;= maxn &amp;&amp; path[tmp * 2] == tmp * 2)\n        &#123;\n            q.push(tmp *2);\n            path[tmp* 2] = tmp;\n            if(tmp * 2 == y) return;\n        &#125;\n        if(tmp - 1 > 0 &amp;&amp; tmp - 1 &lt;= maxn &amp;&amp; path[tmp -1] == tmp -1)\n        &#123;\n            q.push(tmp - 1);\n            path[tmp - 1] = tmp;\n            if(tmp - 1 == y) return;\n        &#125;\n\n    &#125;\n&#125;\n\n完整代码#include&lt;iostream>\n#include&lt;stack>\n#include&lt;queue>\nusing namespace std;\n\nconst int maxn = 100010;\nint path[maxn] = &#123;0&#125;;\n\nvoid bfs(int x, int y)\n&#123;\n    queue&lt;int> q;\n    q.push(x);\n    while(!q.empty())\n    &#123;\n        int tmp = q.front();\n        q.pop();\n        if(tmp + 1 &lt;= maxn &amp;&amp; path[tmp+1] == tmp + 1)\n        &#123;\n            q.push(tmp + 1);\n            path[tmp + 1] = tmp;\n            if(tmp + 1 == y) return;\n        &#125;\n        if(tmp * 2 &lt;= maxn &amp;&amp; path[tmp * 2] == tmp * 2)\n        &#123;\n            q.push(tmp *2);\n            path[tmp* 2] = tmp;\n            if(tmp * 2 == y) return;\n        &#125;\n        if(tmp - 1 > 0 &amp;&amp; tmp - 1 &lt;= maxn &amp;&amp; path[tmp -1] == tmp -1)\n        &#123;\n            q.push(tmp - 1);\n            path[tmp - 1] = tmp;\n            if(tmp - 1 == y) return;\n        &#125;\n\n    &#125;\n&#125;\n\nint main()\n&#123;\n    int x, y, cnt = 0;\n    cin >> x >> y;\n\n    for(int i = 0; i &lt;= maxn - 1; i++)\n    &#123;\n        path[i] = i;\n    &#125;\n    bfs(x, y);\n\n    path[x] = x;\n    stack&lt;int> result;\n    while(path[y] != y)\n    &#123;\n        cnt++;\n        result.push(y);\n        y = path[y];\n    &#125;\n\n    cout &lt;&lt; cnt &lt;&lt; endl;\n\n    while(!result.empty())\n    &#123;\n        cout &lt;&lt; result.top();\n        result.pop();\n        if(!result.empty()) cout &lt;&lt; \" \";\n    &#125;\n    //cout &lt;&lt; endl;\n    return 0;\n&#125;\n\n教训结尾输出空行会导致第一个样例因为格式错误过不了。以后OJ出现这种异常，可以试试更改一下格式。\n第三题：修轻轨全屏浏览题目切换布局\n长春市有n个交通枢纽，计划在1号枢纽到n号枢纽之间修建一条轻轨。轻轨由多段隧道组成，候选隧道有m段。每段候选隧道只能由一个公司施工，施工天数对各家公司一致。有n家施工公司，每家公司同时最多只能修建一条候选隧道。所有公司可以同时开始施工。请评估：修建这条轻轨最少要多少天。\n输入格式第1行，两个整数n和m，用空格分隔，分别表示交通枢纽的数量和候选隧道的数量，1 ≤ n ≤ 100000，1 ≤ m ≤ 200000。\n第2行到第m+1行，每行三个整数a、b、c，用空格分隔，表示枢纽a和枢纽b之间可以修建一条双向隧道，施工时间为c天，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000000。\n输出格式输出一行，包含一个整数，表示最少施工天数。\n输入样例在这里给出一组输入。例如：\n6 6\n1 2 4\n2 3 4\n3 6 7\n1 4 2\n4 5 5\n5 6 6\n\n输出样例在这里给出相应的输出。例如：\n6\n\n题目解析一共有n个枢纽，即使由起点出发，遍历所有枢纽，到达终点，也只需要n-1条边，不需要考虑某一家公司需要完成第一条施工后再施工第二条。我们要求的就是从起点到终点的一条路径，使得该路径上的权值最大值最小，这时候就比较容易联想到最小生成树算法Kruskal，贪心思想，每一次都取最小的边加入并查集。经过推理，发现每次取边之后，判断一下起点和终点在同一集合内，哪怕选取的边最后不会使用，但是这样并不影响完成从起点到终点这一路径过程中的最大值。\n方法一：Kruskal代码实现#include&lt;iostream>\n#include&lt;queue>\n#include&lt;vector>\nusing namespace std;\n\nint pre[100001];\nint cur = 0;\nint n, m, v1, v2, cost_tmp;\n\nint find(int x)\n&#123;\n    if(pre[x] == x) return x;\n    return pre[x] = find(pre[x]);\n&#125;\n\nvoid join(int x, int y)\n&#123;\n    int fx = find(x), fy = find(y);\n    if(fx != fy)\n        pre[fx] = fy;\n&#125;\n\nstruct edge\n&#123;\n    int fr, to;\n    int cost;\n    edge(int _fr, int _to, int _cost):fr(_fr), to(_to), cost(_cost)&#123;&#125;;\n    bool operator >(const edge &amp; b)const\n    &#123;\n        return cost > b.cost;\n    &#125;\n&#125;;\n\npriority_queue&lt;edge,vector&lt;edge>,greater&lt;edge>> list;\n\nint main()\n&#123;\n    scanf(\"%d%d\", &amp;n, &amp;m);\n\n    for(int i = 1; i &lt;= n; i++)\n    &#123;\n        pre[i] = i;\n    &#125;\n\n    for(int i = 0; i &lt;= m - 1; i++)\n    &#123;\n        scanf(\"%d%d%d\", &amp;v1, &amp;v2, &amp;cost_tmp);\n        edge *tmp = new edge(v1, v2, cost_tmp);\n        list.push(*tmp);\n    &#125;\n\n    while(find(n) != find(1))\n    &#123;\n        if(list.empty()) break;\n        edge Edge = list.top();\n        list.pop();\n        int vex1 = Edge.fr;\n        int vex2 = Edge.to;\n        int cost_cur = Edge.cost;\n        if(find(vex1) != find(vex2))\n        &#123;\n            cur = cost_cur;\n            join(vex1,vex2);\n        &#125;\n    &#125;\n\n    printf(\"%d\", cur);\n    return 0;\n&#125;\n\n第四题：发红包新年到了，公司要给员工发红包。员工们会比较获得的红包，有些员工会有钱数的要求，例如，c1的红包钱数要比c2的多。每个员工的红包钱数至少要发888元，这是一个幸运数字。\n公司想满足所有员工的要求，同时也要花钱最少，请你帮助计算。\n输入格式第1行，两个整数n和m(n&lt;&#x3D;10000,m&lt;&#x3D;20000)，用空格分隔，分别代表员工数和要求数。\n接下来m行，每行两个整数c1和c2，用空格分隔，表示员工c1的红包钱数要比c2多，员工的编号1~n 。\n输出格式一个整数，表示公司发的最少钱数。如果公司不能满足所有员工的需求，输出-1.\n输入样例在这里给出一组输入。例如：\n2 1\n1 2\n\n输出样例在这里给出相应的输出。例如：\n1777\n\n题目解析基础红包888元，钱数要求是整数，则可以视为边权均为1。\n假设有三个人：\n1:c1比c2多，c2比c3多。则：最少钱数：c1&#x3D;890, c2&#x3D;889, c3 &#x3D; 888;\n2:出现环：c1比c2多，c2比c3多，c3比c1多。这种情况的出现，会导致该公司不能满足所有员工的需求。\n\n本题目涉及有向，且先后关联，需要判环，应使用AOV拓扑排序。\n方法一：AOV拓扑排序代码实现#include &lt;iostream>\n#include &lt;vector>\n#include &lt;queue>\nusing namespace std;\n\nstruct vertex\n&#123;\n    int val;\n    vertex *next;\n    vertex(int v, vertex *n = nullptr) : val(v), next(n)&#123;&#125;;\n&#125;;\n\nvertex *phead[10001] = &#123;nullptr&#125;, *ptail[10001] = &#123;nullptr&#125;;\nint du[10001];\nint plus_cnt[10001] = &#123;0&#125;;\nqueue&lt;int> q;\nint sum = 0;\nint cnt = 0;\n\nvoid add(int x, int y)\n&#123;\n    vertex *tmp = ptail[x];\n    if (tmp == nullptr)\n    &#123;\n        phead[x] = new vertex(y);\n        ptail[x] = phead[x];\n    &#125;\n    else\n    &#123;\n        ptail[x]->next = new vertex(y);\n        ptail[x] = ptail[x]->next;\n    &#125;\n    du[y]++;\n&#125;\n\nint n, m, v1, v2;\n\nint main()\n&#123;\n    cin >> n >> m;\n    sum = n * 888;\n    for (int i = 0; i &lt;= m - 1; i++)\n    &#123;\n        cin >> v1 >> v2;\n        add(v2, v1);\n    &#125;\n    for (int i = 1; i &lt;= n; i++)\n    &#123;\n        if (du[i] == 0)\n        &#123;\n            q.push(i);\n            cnt++;\n        &#125;\n    &#125;\n    while (!q.empty())\n    &#123;\n        int x;\n        x = q.front();\n        q.pop();\n        vertex *tmp = phead[x];\n        while (tmp != nullptr)\n        &#123;\n            du[tmp->val]--;\n            if (du[tmp->val] == 0)\n            &#123;\n                q.push(tmp->val);\n                cnt++;\n            &#125;\n\n            if (plus_cnt[tmp->val] &lt; plus_cnt[x] + 1)\n            &#123;\n                plus_cnt[tmp->val] = plus_cnt[x] + 1;\n            &#125;\n            tmp = tmp->next;\n        &#125;\n    &#125;\n    int flag = 1;\n    if (cnt != n)\n    &#123;\n        cout &lt;&lt; -1 &lt;&lt; endl;\n        flag = 0;\n    &#125;\n\n    for (int i = 0; i &lt;= n; i++)\n    &#123;\n        sum += plus_cnt[i];\n    &#125;\n\n    if (flag)\n        cout &lt;&lt; sum;\n\n    return 0;\n&#125;\n","slug":"数据结构第四次上机实验","date":"2022-09-06T04:00:18.000Z","categories_index":"数据结构","tags_index":"编程,数据结构","author_index":"Leo Meng"},{"id":"9273a260bb46152a3f86150e633d4306","title":"数据结构第三次上机实验","content":"第一题：连通分量无向图 G 有 n 个顶点和 m 条边。求 G 的连通分量的数目。\n输入格式：第1行，2个整数n和m，用空格分隔，分别表示顶点数和边数， 1≤n≤50000， 1≤m≤100000.\n第2到m+1行，每行两个整数u和v，用空格分隔，表示顶点u到顶点v有一条边，u和v是顶点编号，1≤u,v≤n.\n输出格式：1行，1个整数，表示所求连通分量的数目。\n输入样例：在这里给出一组输入。例如：\n6 5\n1 3\n1 2\n2 3\n4 5\n5 6\n\n输入样例：在这里给出相应的输出。例如：\n2\n\n题目解析：方法一：深度优先遍历通过对每一个连通分量进行DFS（深度优先遍历），来遍历这个连通分量的所有节点，使用vis数组判断是否位于该节点是否位于原来已经遍历过的连通分量中，使用cnt变量来记录分支数量。\n代码实现读入无向图（邻接表）void add(int &amp; a, int &amp; b)\n&#123;\n    node* tmp = phead[a];\n    if(tmp == nullptr)\n    &#123;\n        tmp = new node;\n        tmp->val = b;\n        phead[a] = tmp;\n        ptail[a] = tmp;\n    &#125;\n    else&#123;\n        tmp = new node;\n        tmp->val = b;\n        ptail[a]->next = tmp;\n        ptail[a] = tmp;\n    &#125;\n\n    tmp = phead[b];\n    if(tmp == nullptr)\n    &#123;\n        tmp = new node;\n        tmp->val = a;\n        phead[b] = tmp;\n        ptail[b] = tmp;\n    &#125;\n    else&#123;\n        tmp = new node;\n        tmp->val = a;\n        ptail[b]->next = tmp;\n        ptail[b] = tmp;\n    &#125;\n&#125;\n\nDFSvoid DFS(int x)\n&#123;\n    vis[x] = 1;\n    node* t = phead[x];\n    while(t != nullptr)\n    &#123;\n        if(vis[t->val] == 0) DFS(t->val);\n        t = t->next;\n    &#125;\n&#125;\n\n完整代码#include &lt;iostream>\nusing namespace std;\nclass node\n&#123;\npublic:\n    int val;\n    node* next;\n    node()&#123;next = nullptr;&#125;\n&#125;;\n\nnode* phead[50001] = &#123;nullptr&#125;;\nnode* ptail[50001] = &#123;nullptr&#125;;\nint vis[50001] = &#123;0&#125;;\n\nint n, m, v1, v2, cnt = 0;\n\nvoid add(int &amp; a, int &amp; b)\n&#123;\n    node* tmp = phead[a];\n    if(tmp == nullptr)\n    &#123;\n        tmp = new node;\n        tmp->val = b;\n        phead[a] = tmp;\n        ptail[a] = tmp;\n    &#125;\n    else&#123;\n        tmp = new node;\n        tmp->val = b;\n        ptail[a]->next = tmp;\n        ptail[a] = tmp;\n    &#125;\n\n    tmp = phead[b];\n    if(tmp == nullptr)\n    &#123;\n        tmp = new node;\n        tmp->val = a;\n        phead[b] = tmp;\n        ptail[b] = tmp;\n    &#125;\n    else&#123;\n        tmp = new node;\n        tmp->val = a;\n        ptail[b]->next = tmp;\n        ptail[b] = tmp;\n    &#125;\n&#125;\n\nvoid DFS(int x)\n&#123;\n    vis[x] = 1;\n    node* t = phead[x];\n    while(t != nullptr)\n    &#123;\n        if(vis[t->val] == 0) DFS(t->val);\n        t = t->next;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    cin >> n >> m;\n    for(int i = 0; i &lt;= m - 1; i++)\n    &#123;\n        cin >> v1 >> v2;\n        add(v1, v2);\n    &#125;\n    for(int i = 1; i &lt;= n; i++)\n    &#123;\n        if(vis[i] == 0)\n        &#123;\n            DFS(i);\n            cnt++;\n        &#125;\n    &#125;\n    cout &lt;&lt; cnt &lt;&lt; endl;\n    return 0;\n&#125;\n\n方法二：并查集使用Kruskal算法，用并查集存储每个节点的祖先，最后统计出不同祖先的个数。\n#include &lt;iostream>\n#include &lt;queue>\nusing namespace std;\n\nint cost_sum = 0;\n\nint pre[50001];\n\nint find(int x)\n&#123;\n    if(pre[x] == x) return x;\n    return pre[x] = find(pre[x]);\n&#125;\n\nvoid join(int x, int y)\n&#123;\n    int fx = find(x), fy = find(y);\n    if(fx != fy)\n        pre[fx] = fy;\n&#125;\n\nstruct edge\n&#123;\n    int fr, to;\n&#125;;\n\nqueue&lt;edge> list;\n\nint main()\n&#123;\n    int n, m;\n    cin >> n >> m;\n\n    for(int i = 0; i &lt;= n; i++)\n    &#123;\n        pre[i] = i;\n    &#125;\n\n    for(int i = 0 ; i&lt;= m - 1 ; i++)\n    &#123;\n        int tmp_fr, tmp_to;\n        cin >> tmp_fr >> tmp_to;\n        edge *Edge = new edge;\n        Edge->fr = tmp_fr;\n        Edge->to = tmp_to;\n        list.push(*Edge);\n    &#125;\n\n    while(!list.empty())\n    &#123;\n        edge Edge = list.front();\n        list.pop();\n        int vex1 = Edge.fr;\n        int vex2 = Edge.to;\n        if(find(vex1) != find(vex2))\n        &#123;\n            join(vex1, vex2);\n        &#125;\n    &#125;\n\n    int cnt = 0;\n    for(int i = 1; i &lt;= n; i++)\n    &#123;\n        if(find(i) == i) cnt++;\n    &#125;\n    cout &lt;&lt; cnt &lt;&lt;endl;\n    return 0;\n&#125;\n\n\n第二题：整数拆分整数拆分是一个古老又有趣的问题。请给出将正整数 n 拆分成 k 个正整数的所有不重复方案。例如，将 5 拆分成 2 个正整数的不重复方案，有如下2组：(1，4)和(2，3)。注意(1，4) 和(4，1)被视为同一方案。每种方案按递增序输出，所有方案按方案递增序输出。\n输入格式1行，2个整数n和k，用空格分隔， 1≤k≤n≤50.\n输出格式若干行，每行一个拆分方案，方案中的数用空格分隔。最后一行，给出不同拆分方案的总数。\n输入样例在这里给出一组输入。例如：\n5 2\n\n输出样例在这里给出相应的输出。例如：\n1 4\n2 3\n2\n\n题目解析方法一：回溯法代码实现#include &lt;iostream>\n#include &lt;queue>\n#include &lt;vector>\nusing namespace std;\n\nint n = 0;\nint k = 0;\nint cnt = 0;\n\nvector&lt;int> vec;\n\nint solve(int x, int y, int q, int sum)\n&#123;\n    //如果数字个数达到k个\n    if (y == 0)\n    &#123;\n        //如果sum恰好等于n，输出答案\n        if (sum == n)\n        &#123;\n            ++cnt;\n            for (auto it = vec.begin(); it != vec.end(); ++it)\n            &#123;\n                cout &lt;&lt; *it;\n                if (it != vec.end())\n                    cout &lt;&lt; \" \";\n            &#125;\n            cout &lt;&lt; endl;\n            return 0;\n        &#125;\n        else\n        &#123;\n            return 0;\n        &#125;\n    &#125;\n    //重复方案的筛选，将大于等于q，小于等于x/y的每个数递归solve，保证每个组合元素递增\n    for (int i = q; i &lt;= x / y; ++i)\n    &#123;\n        vec.push_back(i);\n        solve(x - i, y - 1, i, sum + i);\n        vec.pop_back();\n    &#125;\n    return 0;\n&#125;\n\nint main()\n&#123;\n    cin >> n >> k;\n    solve(n, k, 1, 0);\n    cout &lt;&lt; cnt;\n    return 0;\n&#125;\n\n第三题：旅行五一要到了,来一场说走就走的旅行吧。当然，要关注旅行费用。由于从事计算机专业，你很容易就收集到一些城市之间的交通方式及相关费用。将所有城市编号为1到n，你出发的城市编号是s。你想知道，到其它城市的最小费用分别是多少。如果可能，你想途中多旅行一些城市，在最小费用情况下，到各个城市的途中最多能经过多少城市。\n输入格式第1行，3个整数n、m、s，用空格分隔，分别表示城市数、交通方式总数、出发城市编号， 1≤s≤n≤10000, 1≤m≤100000 。\n第2到m+1行，每行三个整数u、v和w，用空格分隔，表示城市u和城市v的一种双向交通方式费用为w ， 1≤w≤10000。\n输出格式第1行，若干个整数Pi，用空格分隔，Pi表示s能到达的城市i的最小费用，1≤i≤n，按城市号递增顺序。\n第2行，若干个整数Ci，Ci表示在最小费用情况下，s到城市i的最多经过的城市数，1≤i≤n，按城市号递增顺序。\n输入样例在这里给出一组输入。例如：\n5 5 1\n1 2 2\n1 4 5\n2 3 4\n3 5 7\n4 5 8\n\n输出样例在这里给出相应的输出。例如：\n0 2 6 5 13\n0 1 2 1 3\n\n题目解析单元最短路问题，首先想到的是Dijkstra。\n求最多经过的城市数，需要对“三角形”进行特判若“两边之和等于第三边”，选择多经过一个城市的路径。\n方法一：Dijkstra代码实现#include &lt;iostream>\n#include &lt;vector>\n#include &lt;queue>\n#include &lt;limit>\nusing namespace std;\n\nclass node\n&#123;\npublic:\n    int val;\n    int cost;\n    node *next;\n    node() &#123; next = nullptr; &#125;\n    node(int v, int c) &#123; val = v, cost = c, next = nullptr; &#125;\n&#125;;\n\nclass edge\n&#123;\npublic:\n    int val;\n    int cost;\n    edge(int c, int v) &#123; val = v, cost = c; &#125;\n    bool operator&lt;(const edge &amp;b) const\n    &#123;\n        return cost > b.cost;\n    &#125;\n&#125;;\n\nnode *phead[10001] = &#123;nullptr&#125;;\nnode *ptail[10001] = &#123;nullptr&#125;;\nint vis[10001] = &#123;0&#125;;\nint citycnt[10001] = &#123;0&#125;;\n\nint n, m, strt, v1, v2, cs;\n\npriority_queue&lt;edge> list;//通过优先队列进行优化\n\nint main()\n&#123;\n    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;strt);\n    int *dist = new int[n + 1];\n    for (int i = 0; i &lt;= m - 1; i++)\n    &#123;\n        scanf(\"%d%d%d\", &amp;v1, &amp;v2, &amp;cs);\n        node *t = ptail[v1];\n        if (t == nullptr)\n        &#123;\n            phead[v1] = new node(v2, cs);\n            ptail[v1] = phead[v1];\n        &#125;\n        else\n        &#123;\n            ptail[v1]->next = new node(v2, cs);\n            ptail[v1] = ptail[v1]->next;\n        &#125;\n\n        t = ptail[v2];\n        if (t == nullptr)\n        &#123;\n            phead[v2] = new node(v1, cs);\n            ptail[v2] = phead[v2];\n        &#125;\n        else\n        &#123;\n            ptail[v2]->next = new node(v1, cs);\n            ptail[v2] = ptail[v2]->next;\n        &#125;\n    &#125;\n    for (int i = 0; i &lt;= n; i++)\n    &#123;\n        dist[i] = INT32_MAX;\n    &#125;\n    dist[strt] = 0;\n    list.push(edge(0, strt));\n    while (!list.empty())\n    &#123;\n        edge cur = list.top();\n        list.pop();\n        if (vis[cur.val] == 1)\n            continue;\n        else\n            vis[cur.val] = 1;\n\n        node *t = phead[cur.val];\n        while (t != nullptr)\n        &#123;\n            if (t->cost + dist[cur.val] &lt; dist[t->val])\n            &#123;\n                dist[t->val] = t->cost + dist[cur.val];\n                list.push(edge(dist[t->val], t->val));\n                citycnt[t->val] = citycnt[cur.val] + 1;\n            &#125;\n            else if (t->cost + dist[cur.val] == dist[t->val])\n            &#123;\n                if (citycnt[t->val] &lt; citycnt[cur.val] + 1)\n                    citycnt[t->val] = citycnt[cur.val] + 1;\n            &#125;\n            t = t->next;\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; i++)\n    &#123;\n        cout &lt;&lt; dist[i];\n        if (i != n)\n            cout &lt;&lt; \" \";\n    &#125;\n    cout &lt;&lt; endl;\n    for (int i = 1; i &lt;= n; i++)\n    &#123;\n        cout &lt;&lt; citycnt[i];\n        if (i != n)\n            cout &lt;&lt; \" \";\n    &#125;\n    cout &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n第四题：供电给N个地区供电。每个地区或者建一个供电站，或者修一条线道连接到其它有电的地区。试确定给N个地区都供上电的最小费用。\n要给N个地区供电。每个地区或者建一个供电站，或者修一条线道连接到其它有电的地区。试确定给N个地区都供上电的最小费用。\n输入格式第1行，两个个整数 N 和 M , 用空格分隔，分别表示地区数和修线路的方案数，1≤N≤10000，0≤M≤50000。\n第2行，包含N个用空格分隔的整数P[i]，表示在第i个地区建一个供电站的代价，1 ≤P[i]≤ 100,000，1≤i≤N 。\n接下来M行，每行3个整数a、b和c，用空格分隔，表示在地区a和b之间修一条线路的代价为c，1 ≤ c ≤ 100,000，1≤a,b≤N 。\n输出格式一行，包含一个整数， 表示所求最小代价。\n输入样例在这里给出一组输入。例如：\n4 6\n5 4 4 3\n1 2 2\n1 3 2\n1 4 2\n2 3 3\n2 4 3\n3 4 4\n\n输出样例在这里给出相应的输出。例如：\n9\n\n题目解析最小生成树问题，但是可以选择自己供电，即本题的图，既有点权，又有边权。可以选择点权化边权，然后使用最小生成树的相关算法完成。\n方法一：Kruskal代码实现#include &lt;iostream>\n#include &lt;vector>\n#include &lt;queue>\nusing namespace std;\n\nint cost_sum = 0;\n\nint pre[10001];\n\nint find(int x)\n&#123;\n    if(pre[x] == x) return x;\n    return pre[x] = find(pre[x]);\n&#125;\n\nvoid join(int x, int y)\n&#123;\n    int fx = find(x), fy = find(y);\n    if(fx != fy)\n        pre[fx] = fy;\n&#125;\n\nstruct edge\n&#123;\n    int fr, to;\n    int cost;\n\n    bool operator >(const edge &amp; b)const\n    &#123;\n        return cost > b.cost;\n    &#125;\n&#125;;\n\npriority_queue&lt;edge,vector&lt;edge>,greater&lt;edge>> list;\n\nint main()\n&#123;\n    int n, m;\n    cin >> n >> m;\n    pre[0] = 0;\n    for(int i = 1; i &lt;= n; i++)\n    &#123;\n        int tmp_cost;\n        cin >> tmp_cost;\n        edge *Edge = new edge;\n        Edge->fr = 0;\n        Edge->to = i;\n        Edge->cost = tmp_cost;\n        list.push(*Edge);\n        pre[i] = i;\n    &#125;\n\n    for(int i = 0 ; i&lt;= m - 1 ; i++)\n    &#123;\n        int tmp_fr, tmp_to, tmp_cost;\n        cin >> tmp_fr >> tmp_to >> tmp_cost;\n        edge *Edge = new edge;\n        Edge->fr = tmp_fr;\n        Edge->to = tmp_to;\n        Edge->cost = tmp_cost;\n        list.push(*Edge);\n    &#125;\n    int T = n + 1;\n    while(T > 1)\n    &#123;\n        edge Edge = list.top();\n        list.pop();\n        int vex1 = Edge.fr;\n        int vex2 = Edge.to;\n        int cost = Edge.cost;\n        if(find(vex1) != find(vex2))\n        &#123;\n            cost_sum += cost;\n            join(vex1, vex2);\n            T--;\n        &#125;\n    &#125;\n    cout &lt;&lt; cost_sum &lt;&lt; endl;\n    return 0;\n&#125;\n","slug":"数据结构第三次上机实验","date":"2022-09-06T03:59:53.000Z","categories_index":"数据结构","tags_index":"编程,数据结构","author_index":"Leo Meng"},{"id":"407b137722e04956b74ff31b7ce67773","title":"数据结构第二次上机实验","content":"第一题：二叉树最长路径给定一棵二叉树T，求T中的最长路径的长度，并输出此路径上各结点的值。若有多条最长路径，输出最右侧的那条。\n输入格式第1行，1个整数n，表示二叉树有n个结点， 1≤n≤100000.\n第2行，2n+1个整数，用空格分隔，表示T的扩展先根序列， -1表示空指针，结点用编号1到n表示。\n输出格式第1行，1个整数length，length表示T中的最长路径的长度。\n第2行，length+1个整数，用空格分隔，表示最右侧的最长路径。\n输入样例在这里给出一组输入。例如：\n5\n1 2 -1 -1 3 4 -1 -1 5 -1 -1\n\n输出样例在这里给出相应的输出。例如：\n2\n1 3 5\n\n题目解析方法一：树的遍历代码实现#include &lt;iostream>\n#include &lt;vector>\n\nusing namespace std;\n\nstruct Tree\n&#123;\n    int left;\n    int right;\n&#125; tree[100001];\n\nint heigth[100001];\nint path[100001] = &#123;0&#125;;\n\nint init()\n&#123;\n    int tmp = 0;\n    cin >> tmp;\n    if (tmp != -1)\n    &#123;\n        tree[tmp].left = init();\n        tree[tmp].right = init();\n    &#125;\n    return tmp;\n&#125;\n\nvoid depth(int node)\n&#123;\n    if (node != -1)\n    &#123;\n        heigth[node] = 1;\n        if (tree[node].right != -1)\n        &#123;\n            depth(tree[node].right);\n            if (heigth[node] &lt; heigth[tree[node].right] + 1)\n                heigth[node] = heigth[tree[node].right] + 1;\n            path[node] = tree[node].right;\n        &#125;\n        if (tree[node].left != -1)\n        &#123;\n            depth(tree[node].left);\n            if (heigth[node] &lt; heigth[tree[node].left] + 1)\n                heigth[node] = heigth[tree[node].left] + 1;\n            if (tree[node].left == -1 || heigth[tree[node].right] &lt; heigth[tree[node].left])\n            &#123;\n                path[node] = tree[node].left;\n            &#125;\n        &#125;\n    &#125;\n    else\n        return;\n&#125;\n\nint main()\n&#123;\n    int n = 0;\n    cin >> n;\n\n    int root = init();\n    depth(root);\n\n    printf(\"%d\\n\", heigth[root] - 1);\n\n    while (root != 0)\n    &#123;\n        printf(\"%d\", root);\n        root = path[root];\n        if (root != 0)\n            printf(\" \");\n    &#125;\n\n    printf(\"\\n\");\n    return 0;\n&#125;\n\n第二题：森林的层次遍历给定一个森林F，求F的层次遍历序列。森林由其先根序列及序列中每个结点的度给出。\n输入格式第1行，1个整数n，表示森林的结点个数， 1≤n≤100000.\n第2行，n个字符，用空格分隔，表示森林F的先根序列。字符为大小写字母及数字。\n第3行，n个整数，用空格分隔，表示森林F的先根序列中每个结点对应的度。\n输出格式1行，n个字符，用空格分隔，表示森林F的层次遍历序列。\n输入样例在这里给出一组输入。例如：\n14\nA B C D E F G H I J K L M N\n4 0 3 0 0 0 0 2 2 0 0 0 1 0\n\n输出样例在这里给出相应的输出。例如：\nA M B C G H N D E F I L J K\n\n题目解析方法一：森林的层次遍历代码实现#include&lt;iostream>\n#include&lt;queue>\n#include&lt;vector>\nusing namespace std;\n\nint n, cnt = 0;\nchar data_x[100010];\nint val[100010];\nvector&lt;int>son[100010];\n\nint build() &#123;\n\tint num;\n\tnum = cnt++;\n\tfor (int i = 0; i &lt; val[num]; i++) &#123;\n\t\tson[num].push_back(build());\n\t&#125;\n\treturn num;\n&#125;\n\nint main() &#123;\n\tcin >> n;\n\tfor (int i = 0; i &lt; n; i++) &#123;\n\t\tcin >> data_x[i];\n\t&#125;\n\tfor (int i = 0; i &lt; n; i++) &#123;\n\t\tcin >> val[i];\n\t&#125;\n\n\tqueue&lt;int>q;\n\n\twhile (cnt != n) &#123;\n\t\tint node;\n\t\tnode = build();\n\t\tq.push(node);\n\t&#125;\n\n\twhile (!q.empty()) &#123;\n\t\tint y;\n\t\ty = q.front();\n\t\tq.pop();\n\t\tcout &lt;&lt; data_x[y];\n\t\tfor (int i = 0; i &lt; val[y]; i++) &#123;\n\t\t\tq.push(son[y][i]);\n\t\t&#125;\n        if(!q.empty()) cout &lt;&lt; \" \";\n\t&#125;\n    \n    cout &lt;&lt; \"\\n\";\n    return 0;\n&#125;\n\n第三题：纸带切割有一条细长的纸带,长度为 L 个单位，宽度为一个单位。现在要将纸带切割成 n 段。每次切割把当前纸带分成两段，切割位置都在整数单位上，切割代价是当前切割纸带的总长度。每次切割都选择未达最终要求的最长纸带切割，若这样的纸带有多条，则任选一条切割。如何切割，才能完成任务，并且总代价最小。\n输入格式第1行，1个整数n，表示切割成的段数， 1≤n≤100000.\n第2行，n个整数Li，用空格分隔，表示要切割成的各段的长度，1≤Li≤200000000，1≤i≤n.\n输出格式第1行，1个整数，表示最小的总代价。\n第2行，若干个整数，用空格分隔，表示总代价最小时每次切割的代价。\n输入样例在这里给出一组输入。例如：\n5\n5 6 7 2 4\n\n输出样例在这里给出相应的输出。例如：\n54\n24 13 11 6\n\n题目解析方法一：哈夫曼合并#include&lt;iostream>\n#include&lt;stack>\n#include&lt;vector>\n#include&lt;queue>\nusing namespace std;\n\npriority_queue&lt;long long, vector&lt;long long>, greater&lt;long long>> list;\nstack&lt;long long> result;\nlong long cost = 0;\n\nint main()\n&#123;\n    int n;\n    cin >> n;\n    for(int i = 0; i &lt;= n - 1; i++)\n    &#123;\n        long long tmp;\n        cin >> tmp;\n        list.push(tmp);\n    &#125;\n    while(list.size() > 1)\n    &#123;\n        long long a, b;\n        a = list.top();\n        list.pop();\n        b = list.top();\n        list.pop();\n        list.push(a+b);\n        result.push(a+b);\n        cost += (a+b);\n    &#125;\n    cout &lt;&lt; cost &lt;&lt; endl;\n    while(!result.empty())\n    &#123;\n        cout &lt;&lt; result.top();\n        result.pop();\n        if(!result.empty()) cout &lt;&lt; \" \";\n    &#125;\n    return 0;\n&#125;\n\n第四题：序列乘积两个递增序列A和B,长度都是n。令 Ai 和 Bj 做乘积，1≤i,j≤n.请输出n*n个乘积中从小到大的前n个。\n输入格式第1行，1个整数n，表示序列的长度， 1≤n≤100000.\n第2行，n个整数Ai，用空格分隔，表示序列A，1≤Ai≤40000，1≤i≤n.\n第3行，n个整数Bi，用空格分隔，表示序列B，1≤Bi≤40000，1≤i≤n.\n输出格式1行，n个整数，用空格分隔，表示序列乘积中的从小到大前n个。\n输入样例在这里给出一组输入。例如：\n5\n1 3 5 7 9 \n2 4 6 8 10\n\n输出样例在这里给出相应的输出。例如：\n2 4 6 6 8\n\n题目解析方法一：STL priority_queue先将第一行入队（大根堆），然后遍历每一列，弹出堆顶元素，将当前元素压入堆中，直到出现第一个不在前n个的，开始遍历下一列。\n#include&lt;iostream>\n#include&lt;queue>\nusing namespace std;\npriority_queue&lt;int , vector&lt;int>, less&lt;int>> list;\nint a[100001], b[100001];\nint n;\nint main()\n&#123;\n    cin >> n;\n    for(int i = 0; i &lt;= n - 1; i++)\n    &#123;\n        cin >> a[i];\n    &#125;\n    for(int i = 0; i &lt;= n - 1; i++)\n    &#123;\n        cin >> b[i];\n    &#125;\n    for(int i = 0; i &lt;= n - 1; i++)\n    &#123;\n        list.push(a[0] * b[i]);\n    &#125;\n    for(int i = 1; i &lt;= n - 1; i++)\n    &#123;\n        for(int j = 0; j &lt;= n - 1; j++)\n        &#123;\n            if(a[i]* b[j] &lt; list.top())\n            &#123;\n                list.pop();\n                list.push(a[i]* b[j]);\n            &#125;\n            else break;\n        &#125;\n    &#125;\n    int *tmp = new int[n];\n    for(int i = 0; i &lt;= n - 1; i++)\n    &#123;\n        tmp[i] = list.top();\n        list.pop();\n    &#125;\n    for(int i = n - 1; i >= 0;i--)\n    &#123;\n        cout &lt;&lt; tmp[i];\n        if(i != 0) cout &lt;&lt; \" \";\n    &#125;\n    cout &lt;&lt; endl;\n    delete[]tmp;\n    return 0;\n&#125;\n\n","slug":"数据结构第二次上机实验","date":"2022-09-06T03:30:53.000Z","categories_index":"数据结构","tags_index":"编程,数据结构","author_index":"Leo Meng"},{"id":"18130e5d5310914bcb5bf033ca30cfcc","title":"数据结构第一次上机实验","content":"第一题：数列查询已知数列的通项公式为:\nf(n) = f(n-1)*11/10，f[1]=10. \n\n通项从左向右计算，*和&#x2F;分别表示整数乘法和除法。现在，要多次查询数列项的值。\n输入格式第1行，1个整数q，表示查询的次数， 1≤q≤10000.第2至q+1行，每行1个整数i，表示要查询f(i)的值。\n输出格式q行，每行1个整数，表示f(i)的值。查询的值都在32位整数范围内。\n输入样例在这里给出一组输入。例如：\n3\n1\n2\n3\n\n输出样例在这里给出相应的输出。例如：\n10\n11\n12\n\n题目解析方法一：全结果缓存这样每次查询的代价是O(1)级。\n代码实现#include &lt;iostream>\n#include &lt;string>\n#include &lt;stack>\n#include &lt;queue>\nusing namespace std;\nint n,s,val[10000];\nint main()&#123;\n\tval[1]=10;\n\tcin >> n;\n\tfor(int i=2;i&lt;=202;i++)&#123;\n\t\tval[i]=val[i-1]*11/10;\n\t&#125;\n\twhile(n--)&#123;\n\t\tscanf(\"%d\",&amp;s);\n\t\tprintf(\"%d\\n\",val[s]);\n\t&#125;\n\treturn 0; \n&#125;\n\n第二题：报数游戏n个人围成一圈，从1开始依次编号，做报数游戏。 现指定从第1个人开始报数，报数到第m个人时，该人出圈，然后从其下一个人重新开始报数，仍是报数到第m个人出圈，如此重复下去，直到所有人都出圈。总人数不足m时将循环报数。请输出所有人出圈的顺序。\n输入格式一行，两个整数n和m。n表示游戏的人数，m表示报数出圈的数字，1≤n≤50000，1≤m≤100.\n输出格式一行，n个用空格分隔的整数，表示所有人出圈的顺序\n输入样例在这里给出一组输入。例如：\n5 2\n\n输出样例在这里给出相应的输出。例如：\n2 4 1 5 3\n\n题目解析方法一：使用vector模拟循环链表代码实现#include&lt;iostream>\n#include&lt;string>\n#include&lt;algorithm>\n#include&lt;vector>\nusing namespace std;\nint main()\n&#123;\n\tvector&lt;int>vec;\n\tint n, m;\n\tcin >> n  >> m;\n\tfor (int i = 1; i &lt;= n; i++)\n\t&#123;\n\t\tvec.push_back(i);\n\t&#125;\n\tauto p = vec.begin();\n\twhile(vec.size()-1)\n\t&#123;\n\t\tfor (int j = 0; j &lt; m-1; j++)\n\t\t&#123;\n\t\t\tp++;\n\t\t\tif (p == vec.end())\n\t\t\t\tp = vec.begin();\n\t\t&#125;\n\t\tcout &lt;&lt; *p &lt;&lt; \" \";\n\t\tp = vec.erase(p);\n\t\tif (p == vec.end())\n\t\t\tp = vec.begin();\n\t&#125;\n    cout &lt;&lt; vec[0];\n    return 0;\n&#125;\n\n第三题：算术表达式计算任务: 计算算术表达式的值。\n算术表达式按中缀给出，以&#x3D;号结束，包括+,-,,&#x2F;四种运算和(、)分隔符。运算数的范围是非负整数，没有正负符号，小于等于109 。\n计算过程中,如果出现除数为0的情况,表达式的结果为”NaN” ; 如果中间结果超出32位有符号整型范围,仍按整型计算，不必特殊处理。输入保证表达式正确。\n输入格式一行，包括1个算术表达式。算术表达式的长度小于等于1000。\n输出格式一行，算术表达式的值 。\n输入样例在这里给出一组输入。例如：\n(1+30)/3=\n\n输出样例在这里给出相应的输出。例如：\n10\n\n题目解析方法一：使用栈完成后缀表达式的计算+高精度代码实现#include &lt;iostream>\n#include &lt;stack>\n#include &lt;cstring>\n#include &lt;stdlib.h>\nusing namespace std;\n\nint priority(char a)\n&#123;\n    int prior = 0;\n    if (a == '(')\n        prior = 0;\n    if (a == '-' || a == '+')\n        prior = 1;\n    if (a == '/' || a == '*')\n        prior = 2;\n    return prior;\n&#125;\n\n\nint main()\n&#123;\n    string str;\n    cin >> str;\n    int s1[1000];\n    memset(s1, 0, sizeof(s1));\n    char s2[1000];\n    int top1 = 0, top2 = 0;\n    int num;\n    bool flag = 0;\n    int len = str.size();\n    for (int i = 0; i &lt;= len - 1; i++)\n    &#123;\n        num = 0;\n        while (str[i] >= '0' &amp;&amp; str[i] &lt;= '9')\n        &#123;\n            num = num * 10 + str[i] - '0';\n            i++;\n            flag = 1;\n        &#125;\n        if (flag)\n        &#123;\n            flag = 0;\n            s1[top1++] = num;\n            num = 0;\n        &#125;\n        if (str[i] == '=')\n            break;\n        else if (!(str[i] >= '0' &amp;&amp; str[i] &lt;= '9'))\n        &#123;\n            if (top2==0)\n                s2[top2++] = str[i];\n            else if (str[i] == '(')\n                s2[top2++] = str[i];\n            else if (str[i] == '*' || str[i] == '/' || str[i] == '-' || str[i] == '+')\n            &#123;\n                while (priority(str[i]) &lt;= priority(s2[top2 - 1]))\n                &#123;\n                    int x, y;\n                    y = s1[--top1];\n                    x = s1[--top1];\n                    switch (s2[top2-1])\n                    &#123;\n                    case '+':\n                        s1[top1++] = x + y;\n                        break;\n                    case '-':\n                        s1[top1++] = x - y;\n                        break;\n                    case '*':\n                        s1[top1++] = x * y;\n                        break;\n                    case '/':\n                    &#123;\n                        if (y == 0)\n                        &#123;\n                            std::cout &lt;&lt; \"NaN\";\n                            return 0;\n                        &#125;\n                        else\n                            s1[top1++] = x / y;\n                        break;\n                    &#125;\n                    default:\n                        break;\n                    &#125;\n                    top2--;\n                &#125;\n                if (priority(str[i]) > priority(s2[top2 - 1]))\n                &#123;\n                    s2[top2++] = str[i];\n                &#125;\n            &#125;\n            if (str[i] == ')')\n            &#123;\n                while (s2[top2- 1] != '(')\n                &#123;\n                    int x, y;\n                    y = s1[--top1];\n                    x = s1[--top1];\n                    switch (s2[top2-1])\n                    &#123;\n                    case '+':\n                        s1[top1++] = x+y;\n                        break;\n                    case '-':\n                        s1[top1++] = x-y;\n                        break;\n                    case '*':\n                        s1[top1++] = x*y;\n                        break;\n                    case '/':\n                    &#123;\n                        if (y == 0)\n                        &#123;\n                            std::cout &lt;&lt; \"NaN\";\n                            return 0;\n                        &#125;\n                        else\n                            s1[top1++] = x/y;\n                        break;\n                    &#125;\n                    default:\n                        break;\n                    &#125;\n                    top2--;\n                &#125;\n                top2--;\n            &#125;\n        &#125;\n    &#125;\n    while (top2 != 0)\n    &#123;\n        int x, y;\n        y = s1[--top1];\n        x = s1[--top1];\n        switch (s2[top2 - 1])\n        &#123;\n        case '+':\n            s1[top1++] = x + y;\n            break;\n        case '-':\n            s1[top1++] = x - y;\n            break;\n        case '*':\n            s1[top1++] = x * y;\n            break;\n        case '/':\n        &#123;\n            if (y == 0)\n            &#123;\n                std::cout &lt;&lt; \"NaN\";\n                return 0;\n            &#125;\n            else\n                s1[top1++] = x / y;\n            break;\n        &#125;\n\n        default:\n            break;\n        &#125;\n        top2--;\n    &#125;\n    std::cout &lt;&lt; s1[top1 -1];\n    return 0;\n&#125;\n\n第四题：最喜爱的序列 小唐这段时间在研究序列。拿来N个整数的序列，他给序列中的每个整数都赋予一个喜爱值。喜爱值也是整数，有正有负，越大表明越喜欢。他想知道，如何从序列中连续取最多m个数，他获得喜爱值最大。1≤N≤500000，1≤m≤N。\n输入格式第一行是两个整数N,m。分别代表序列中数的个数以及能取的最多个数。\n第二行用空格隔开的N个整数，第i个整数Li代表他对第i个数的喜爱值。│Li│≤1000\n输出格式一行，三个数，表示获得最大喜爱值，及第一个取最大喜爱值的区间。\n输入样例在这里给出一组输入。例如：\n5 2\n1 4 5 2 3\n\n输出样例在这里给出相应的输出。例如：\n9 2 3\n\n题目解析方法一：单调队列代码实现#include&lt;iostream>\n#include&lt;string>\n#include&lt;algorithm>\n#include&lt;deque>\nconst int maxn= 500010;\nusing namespace std;\nint main()&#123;\n\tint n,m;\n\tdeque&lt;int> Q;\n\tint i,x,max,j,front,end;\n\tint val[maxn];\n\tcin>> n >> m;\n\tval[0]=0;\n\tfor(i=1;i&lt;=n;i++)&#123;\n\t\tscanf(\"%d\",&amp;x);\n\t\tval[i]=x+val[i-1];\n\t&#125;\n    max=0;\n    \n    for(i=1;i&lt;=n;i++)&#123;\n    \twhile(!Q.empty()&amp;&amp;\n              val[Q.front()]>val[i]) Q.pop_front();\n    \tQ.push_front(i);\n    \twhile(!Q.empty()&amp;&amp;Q.back()&lt;i-m) Q.pop_back();\n    \tif(max&lt;val[i]-val[Q.back()])&#123; \n    \t\tmax=val[i]-val[Q.back()];\n    \t\tfront=Q.back()+1;\n    \t\tend=i;\n\t\t&#125;\n\t&#125;\n\tprintf(\"%d %d %d\",max,front,end);\n\treturn 0;\n&#125;\n\n","slug":"数据结构第一次上机实验","date":"2022-09-06T03:00:53.000Z","categories_index":"数据结构","tags_index":"编程,数据结构","author_index":"Leo Meng"}]